{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"yfinance documentation","text":""},{"location":"#download-market-data-from-yahoo-finances-api","title":"Download Market Data from Yahoo! Finance's API","text":"<p>Important Legal Disclaimer: Yahoo!, Y!Finance, and Yahoo! finance are registered trademarks of Yahoo, Inc.</p> <p>yfinance is not affiliated, endorsed, or vetted by Yahoo, Inc. It's an open-source tool that uses Yahoo's publicly available APIs, and is intended for research and educational purposes.</p> <p>You should refer to Yahoo!'s terms of use (here), (here), and (here) for details on your rights to use the actual data downloaded. Remember - the Yahoo! finance API is intended for personal use only.</p>"},{"location":"#install","title":"Install","text":"<pre><code>$ pip install yfinance\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<p>Showing a small sample of yfinance API, the full API is much bigger and covered in reference/index.</p> <pre><code>import yfinance as yf\ndat = yf.Ticker(\"MSFT\")\n</code></pre> <p>One ticker symbol</p> <pre><code>dat = yf.Ticker(\"MSFT\")\ndat.info\ndat.calendar\ndat.analyst_price_targets\ndat.quarterly_income_stmt\ndat.history(period='1mo')\ndat.option_chain(dat.options[0]).calls\n</code></pre> <p>Multiple ticker symbols</p> <pre><code>tickers = yf.Tickers('MSFT AAPL GOOG')\ntickers.tickers['MSFT'].info\nyf.download(['MSFT', 'AAPL', 'GOOG'], period='1mo')\n</code></pre> <p>Funds</p> <pre><code>spy = yf.Ticker('SPY').funds_data\nspy.description\nspy.top_holdings\n</code></pre> <ul> <li>Advanced</li> <li>Reference</li> <li>Development</li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#submitting-a-new-issue","title":"Submitting a new issue","text":"<ul> <li>Search through existing Issues and Discussions, in case your issue already exists and a solution is being developed.</li> <li>Ensure you read &amp; follow the template form.</li> <li>Consider you may be the best person to investigate and fix.</li> </ul>"},{"location":"CODE_OF_CONDUCT/#contributing-to-an-existing-issue","title":"Contributing to an existing Issue","text":"<ul> <li>Read the entire thread.</li> <li>Ensure your comment is contributing something new/useful. Remember you can simply react to other comments.</li> <li>Be concise:</li> <li>use the formatting options</li> <li>if replying to a big comment, instead of quoting it, link to it</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing","text":"<p>yfinance relies on the community to investigate bugs and contribute code.</p> <p>This is a quick short guide, full guide at https://ranaroussi.github.io/yfinance/development/index.html</p>"},{"location":"CONTRIBUTING/#branches","title":"Branches","text":"<p>YFinance uses a two-layer branch model:</p> <ul> <li>dev: new features &amp; most bug-fixes merged here, tested together, conflicts fixed, etc.</li> <li>main: stable branch where PIP releases are created.</li> </ul>"},{"location":"CONTRIBUTING/#running-a-branch","title":"Running a branch","text":"<pre><code>pip install git+ranaroussi/yfinance.git@dev  # &lt;- dev branch\n</code></pre> <p>https://ranaroussi.github.io/yfinance/development/running.html</p>"},{"location":"CONTRIBUTING/#im-a-github-newbie-how-do-i-contribute-code","title":"I'm a GitHub newbie, how do I contribute code?","text":"<ol> <li> <p>Fork this project. If already forked, remember to <code>Sync fork</code></p> </li> <li> <p>Implement your change in your fork, ideally in a specific branch</p> </li> <li> <p>Create a Pull Request, from your fork to this project. If addressing an Issue, link to it</p> </li> </ol> <p>https://ranaroussi.github.io/yfinance/development/code.html</p>"},{"location":"CONTRIBUTING/#documentation-website","title":"Documentation website","text":"<p>The new docs website is generated automatically from code. https://ranaroussi.github.io/yfinance/index.html</p> <p>Remember to updates docs when you change code, and check docs locally.</p> <p>https://ranaroussi.github.io/yfinance/development/documentation.html</p>"},{"location":"CONTRIBUTING/#git-tricks","title":"Git tricks","text":"<p>Help keep the Git commit history and network graph compact:</p> <ul> <li> <p>got a long descriptive commit message? <code>git commit -m \"short sentence summary\" -m \"full commit message\"</code></p> </li> <li> <p>combine multiple commits into 1 with <code>git squash</code></p> </li> <li> <p><code>git rebase</code> is your friend: change base branch, or \"merge in\" updates</p> </li> </ul> <p>https://ranaroussi.github.io/yfinance/development/code.html#git-stuff</p>"},{"location":"CONTRIBUTING/#unit-tests","title":"Unit tests","text":"<p>Tests have been written using the built-in Python module <code>unittest</code>. Examples:</p> <ul> <li>Run all tests: <code>python -m unittest discover -s tests</code></li> </ul> <p>https://ranaroussi.github.io/yfinance/development/testing.html</p> <p>See the Developer Guide for more information.</p>"},{"location":"advanced/","title":"Advanced","text":"<ul> <li>Logging</li> <li>Config</li> <li>Caching</li> <li>Multi Level Columns</li> <li>Price Repair</li> </ul>"},{"location":"advanced/caching/","title":"Caching","text":""},{"location":"advanced/caching/#persistent-cache","title":"Persistent Cache","text":"<p>To reduce Yahoo, yfinance store some data locally: timezones to localize dates, and cookie. Cache location is:</p> <ul> <li>Windows = C:/Users/\\&lt;USER&gt;/AppData/Local/py-yfinance</li> <li>Linux = /home/\\&lt;USER&gt;/.cache/py-yfinance</li> <li>MacOS = /Users/\\&lt;USER&gt;/Library/Caches/py-yfinance</li> </ul> <p>You can direct cache to use a different location with <code>set_tz_cache_location (yfinance.set_tz_cache_location)</code>:</p> <pre><code>import yfinance as yf\nyf.set_tz_cache_location(\"custom/cache/location\")\n</code></pre>"},{"location":"advanced/config/","title":"Config","text":"<p><code>yfinance</code> has a new global config for sharing common values.</p>"},{"location":"advanced/config/#proxy","title":"Proxy","text":"<p>Set proxy once in config, affects all yfinance data fetches.</p> <pre><code>import yfinance as yf\nyf.set_config(proxy=\"PROXY_SERVER\")\n</code></pre>"},{"location":"advanced/logging/","title":"Logging","text":"<p><code>yfinance</code> uses the <code>logging</code> module to handle messages. By default, only errors are logged.</p> <p>If debugging, you can switch to debug mode with custom formatting using:</p> <pre><code>import yfinance as yf\nyf.enable_debug_mode()\n</code></pre>"},{"location":"advanced/multi_level_columns/","title":"Multi-Level Column Index","text":"<p>The following answer on Stack Overflow is for How to deal with multi-level column names downloaded with yfinance?</p> <ul> <li><code>yfinance</code> returns a <code>pandas.DataFrame</code> with     multi-level column names, with a level for the ticker and a level     for the stock price data</li> </ul> <p>The answer discusses:</p> <ul> <li>How to correctly read the the multi-level columns after saving the     dataframe to a csv with <code>pandas.DataFrame.to_csv</code></li> <li>How to download single or multiple tickers into a singledataframe     with single level column names and a ticker column</li> </ul>"},{"location":"advanced/price_repair/","title":"Price Repair","text":"<p>The new argument <code>repair=True</code> in <code>history()</code> and <code>download()</code> will attempt to fix a variety of price errors caused by Yahoo. Only US market data appears perfect, I guess Yahoo doesn't care much about rest of world?</p> <p>The returned table will have a new column <code>Repaired?</code> that specifies if row was repaired.</p>"},{"location":"advanced/price_repair/#price-repair_1","title":"Price repair","text":""},{"location":"advanced/price_repair/#missing-dividend-adjustment","title":"Missing dividend adjustment","text":"<p>If dividend in data but preceding <code>Adj Close</code> = <code>Close</code>, then manually apply dividend-adjustment to <code>Adj Close</code>. Note: <code>Repaired?</code> is NOT set to <code>True</code> because fix only changes <code>Adj Close</code></p> 8TRA.DE"},{"location":"advanced/price_repair/#missing-split-adjustment","title":"Missing split adjustment","text":"<p>If stock split in data but preceding price data is not adjusted, then manually apply stock split. Requires date range include 1 day after stock split for calibration - sometimes Yahoo fails to adjust prices on stock split day.</p> MOB.ST"},{"location":"advanced/price_repair/#missing-data","title":"Missing data","text":"<p>If price data is clearly missing or corrupt, then reconstructed using smaller interval e.g. <code>1h</code> to fix <code>1d</code> data.</p> 1COV.DE missing row 1COV.DE missing Volume, but intraday price changed 0316.HK missing Volume, but daily price changed"},{"location":"advanced/price_repair/#100x-errors","title":"100x errors","text":"<p>Sometimes Yahoo mixes up currencies e.g. \\$/cents or \u00a3/pence. So some prices are 100x wrong. Sometimes they are spread randomly through data - these detected with <code>scipy</code> module. Other times they are in a block, because Yahoo decided one day to permanently switch currency.</p> AET.L"},{"location":"advanced/price_repair/#price-reconstruction-algorithm-notes","title":"Price reconstruction - algorithm notes","text":"<p>Spam minimised by grouping fetches. Tries to be aware of data limits e.g. <code>1h</code> cannot be fetched beyond 2 years.</p> <p>If Yahoo eventually does fix the bad data that required reconstruction, you will see it's slightly different to reconstructed prices and volume often significantly different. Best I can do, and beats missing data.</p>"},{"location":"advanced/price_repair/#dividend-repair-new","title":"Dividend repair (new)","text":"<p>Fix errors in dividends:</p> <ol> <li>adjustment missing or 100x too small/big for the dividend</li> <li>duplicate dividend (within 7 days)</li> <li>dividend 100x too big/small for the ex-dividend price drop</li> <li>ex-div date wrong (price drop is few days/weeks after)</li> </ol> <p>Most errors I've seen are on London stock exchange (\u00a3/pence mixup), but no exchange is safe.</p>"},{"location":"advanced/price_repair/#important-false-positives","title":"IMPORTANT - false positives","text":"<p>Because fixing (3) relies on price action, there is a chance of a \"false positive\" (FP) - thinking an error exists when data is good. FP rate increases with longer intervals, so only 1d intervals are repaired. If you request repair on multiday intervals (weekly etc), then: 1d is fetched from Yahoo, repaired, then resampled - this has nice side-effect of solving Yahoo's flawed way of div-adjusting multiday intervals.</p> <p>FP rate on 1d is tiny. They tend to happen with tiny dividends e.g. 0.5%, mistaking normal price volatility for an ex-div drop 100x bigger than the dividend, causing repair of the \"too small\" dividend (repair logic already tries to account for normal volatility by subtracting median). Either accept the risk, or fetch 6-12 months of prices with at least 2 dividends - then can analyse the dividends together to identify false positives.</p>"},{"location":"advanced/price_repair/#adjustment-missing","title":"Adjustment missing","text":"<p>1398.HK</p> <pre><code># ORIGINAL:\n                           Close  Adj Close  Dividends\n2024-07-08 00:00:00+08:00   4.33       4.33   0.335715\n2024-07-04 00:00:00+08:00   4.83       4.83   0.000000\n</code></pre> <pre><code># REPAIRED:\n                           Close  Adj Close  Dividends\n2024-07-08 00:00:00+08:00   4.33   4.330000   0.335715\n2024-07-04 00:00:00+08:00   4.83   4.494285   0.000000\n</code></pre>"},{"location":"advanced/price_repair/#adjustment-too-small","title":"Adjustment too small","text":"<p>3IN.L</p> <pre><code># ORIGINAL:\n                           Close  Adj Close  Dividends\n2024-06-13 00:00:00+01:00  3.185   3.185000    0.05950\n2024-06-12 00:00:00+01:00  3.270   3.269405    0.00000\n</code></pre> <pre><code># REPAIRED:\n                           Close  Adj Close  Dividends\n2024-06-13 00:00:00+01:00  3.185   3.185000    0.05950\n2024-06-12 00:00:00+01:00  3.270   3.210500    0.00000\n</code></pre>"},{"location":"advanced/price_repair/#duplicate-within-7-days","title":"Duplicate (within 7 days)","text":"<p>ALC.SW</p> <pre><code># ORIGINAL:\n                               Close  Adj Close  Dividends\n2023-05-10 00:00:00+02:00  70.580002  70.352142       0.21\n2023-05-09 00:00:00+02:00  65.739998  65.318443       0.21\n2023-05-08 00:00:00+02:00  66.379997  65.745682       0.00\n</code></pre> <pre><code># REPAIRED:\n                               Close  Adj Close  Dividends\n2023-05-10 00:00:00+02:00  70.580002  70.352142       0.00\n2023-05-09 00:00:00+02:00  65.739998  65.527764       0.21\n2023-05-08 00:00:00+02:00  66.379997  65.956371       0.00\n</code></pre>"},{"location":"advanced/price_repair/#dividend-too-big","title":"Dividend too big","text":"<p>HLCL.L</p> <pre><code># ORIGINAL:\n                           Close  Adj Close  Dividends\n2024-06-27 00:00:00+01:00  2.360     2.3600       1.78\n2024-06-26 00:00:00+01:00  2.375     2.3572       0.00\n\n# REPAIRED:\n                           Close  Adj Close  Dividends\n2024-06-27 00:00:00+01:00  2.360     2.3600     0.0178\n2024-06-26 00:00:00+01:00  2.375     2.3572     0.0000\n</code></pre>"},{"location":"advanced/price_repair/#dividend-adjust-too-big","title":"Dividend &amp; adjust too big","text":"<p>LTI.L</p> <pre><code># ORIGINAL:\n                           Close  Adj Close     Adj  Dividends\n2024-08-08 00:00:00+01:00  768.0      768.0  1.0000     5150.0\n2024-08-07 00:00:00+01:00  819.0    -4331.0 -5.2882        0.0\n                           Close  Adj Close     Adj  Dividends\n2024-08-08 00:00:00+01:00  768.0      768.0  1.0000       51.5\n2024-08-07 00:00:00+01:00  819.0      767.5  0.9371        0.0\n</code></pre>"},{"location":"advanced/price_repair/#dividend-too-small","title":"Dividend too small","text":"<p>BVT.L</p> <pre><code># ORIGINAL:\n                            Close  Adj Close     Adj  Dividends\n2022-02-03 00:00:00+00:00  0.7534   0.675197  0.8962    0.00001\n2022-02-01 00:00:00+00:00  0.7844   0.702970  0.8962    0.00000\n</code></pre> <pre><code># REPAIRED:\n                            Close  Adj Close     Adj  Dividends\n2022-02-03 00:00:00+00:00  0.7534   0.675197  0.8962      0.001\n2022-02-01 00:00:00+00:00  0.7844   0.702075  0.8950      0.000\n</code></pre>"},{"location":"advanced/price_repair/#adjusted-2x-on-day-before","title":"Adjusted 2x on day before","text":"<p>clue: Close \\&lt; Low</p> <p>2020.OL</p> <pre><code># ORIGINAL:\n                                  Low       Close   Adj Close  Dividends\n2023-12-21 00:00:00+01:00  120.199997  121.099998  118.868782       0.18\n2023-12-20 00:00:00+01:00  122.000000  121.900002  119.477371       0.00\n</code></pre> <pre><code># REPAIRED:\n                                  Low       Close   Adj Close  Dividends\n2023-12-21 00:00:00+01:00  120.199997  121.099998  118.868782       0.18\n2023-12-20 00:00:00+01:00  122.000000  122.080002  119.654045       0.00\n</code></pre>"},{"location":"advanced/price_repair/#ex-div-date-wrong","title":"ex-div date wrong","text":"<p>TETY.ST</p> <pre><code># ORIGINAL:\n                               Close  Adj Close  Dividends\n2022-06-22 00:00:00+02:00  66.699997  60.085415        0.0\n2022-06-21 00:00:00+02:00  71.599998  64.499489        0.0\n2022-06-20 00:00:00+02:00  71.800003  64.679657        5.0\n2022-06-17 00:00:00+02:00  71.000000  59.454838        0.0\n</code></pre> <pre><code># REPAIRED:\n                               Close  Adj Close  Dividends\n2022-06-22 00:00:00+02:00  66.699997  60.085415        5.0\n2022-06-21 00:00:00+02:00  71.599998  60.007881        0.0\n2022-06-20 00:00:00+02:00  71.800003  60.175503        0.0\n2022-06-17 00:00:00+02:00  71.000000  59.505021        0.0\n</code></pre>"},{"location":"development/","title":"Development","text":"<p>yfinance relies on the community to investigate bugs and contribute code. Here's how you can help:</p> <ul> <li>Code</li> <li>Running</li> <li>Documentation</li> <li>Testing</li> </ul>"},{"location":"development/code/","title":"Code","text":"<p>To support rapid development without breaking stable versions, this project uses a two-layer branch model:</p> <p></p> <p>Inspiration</p> <ul> <li>dev: New features and some bug fixes are merged here. This     branch allows collective testing, conflict resolution, and further     stabilization before merging into the stable branch.</li> <li>main: Stable branch where PIP releases are created.</li> </ul> <p>By default, branches target main, but most contributions should target dev.</p> <p>Exceptions: Direct merges to main are allowed if:</p> <ul> <li><code>yfinance</code> is massively broken</li> <li>Part of <code>yfinance</code> is broken, and the fix is simple and     isolated</li> <li>Not updating the code (e.g. docs)</li> </ul>"},{"location":"development/code/#creating-your-branch","title":"Creating your branch","text":"<ol> <li> <p>Fork the repository on GitHub. If already forked, remember to     <code>Sync fork</code></p> </li> <li> <p>Clone your forked repository:     <code>bash     git clone https://github.com/{user}/{repo}.git</code></p> </li> <li> <p>Create a new branch for your feature or bug fix, from appropriate     base branch:     <code>bash     git checkout {base e.g. dev}     git pull     git checkout -b {your branch}</code></p> </li> <li> <p>Make your changes, commit them, and push your branch to GitHub. To     keep the commit history and network     graph compact, give     your commits a very short summary then description:     <code>bash     git commit -m \"short sentence summary\" -m \"full commit message\"     # Long message can be multiple lines (tip: copy-paste)</code></p> </li> <li> <p>Open a pull request on     Github.</p> </li> </ol>"},{"location":"development/code/#running-a-branch","title":"Running a branch","text":"<p>Please see this page.</p>"},{"location":"development/code/#git-stuff","title":"Git stuff","text":"<ul> <li> <p>You might be asked to move your branch from <code>main</code> to <code>dev</code>. This is     a <code>git rebase</code>. Remember to update all branches involved.     <code>bash     # update all branches:     git checkout main     git pull     git checkout dev     git pull     # rebase from main to dev:     git checkout {your branch}     git pull     git rebase --onto dev main {your branch}     git push --force-with-lease origin {your branch}</code></p> </li> <li> <p><code>git</code> / <code>rebase</code> can also be used to update your branch with new commits     from base, but without adding a commit to your branch history like     git merge does. This keeps history clean and avoids future merge     problems.     <code>bash     git checkout {base branch e.g. dev}     git pull     git checkout {your branch}     git rebase {base}     git push --force-with-lease origin {your branch}</code></p> </li> <li> <p><code>git</code> / <code>squash</code> tiny or negligible commits with meaningful ones, or to     combine successive related commits. git squash     guide <code>bash     git rebase -i HEAD~2     git push --force-with-lease origin {your branch}</code></p> </li> </ul>"},{"location":"development/documentation/","title":"Documentation","text":"<p>Documentation:</p>"},{"location":"development/documentation/#about-documentation","title":"About documentation","text":"<ul> <li>yfinance documentation is written in reStructuredText (rst) and     built using Sphinx.</li> <li>The documentation file is in <code>doc/source/..</code>.</li> <li>Most of the notes under API References read from class and methods     docstrings. These documentations, found in     <code>doc/source/reference/api</code> is autogenerated by Sphinx and not     included in git.</li> </ul>"},{"location":"development/documentation/#building-documentation-locally","title":"Building documentation locally","text":"<p>To build the documentation locally, follow these steps:</p> <ol> <li> <p>Install Required Dependencies:</p> <ul> <li>Make sure <code>Sphinx</code> and any other dependencies are installed. If     a <code>requirements.txt</code> file is available, you can install     dependencies by running: <code>bash pip install -r requirements.txt pip install Sphinx==8.0.2 pydata-sphinx-theme==0.15.4 Jinja2==3.1.4 sphinx-copybutton==0.5.2</code></li> </ul> </li> <li> <p>Build with Sphinx:</p> <ul> <li>After dependencies are installed, use the sphinx-build command     to generate HTML documentation.</li> <li>Go to <code>doc/</code> directory Run: <code>bash sphinx-build -b html doc/source doc/_build/html</code></li> </ul> </li> <li> <p>View Documentation Locally:     <code>bash     python -m http.server -d ./doc/_build/html</code></p> <p>Then open \"localhost:8000\" in browser</p> </li> </ol>"},{"location":"development/documentation/#publishing-documentation","title":"Publishing documentation","text":"<p>Merge into <code>main</code> branch triggers auto-generating documentation by action <code>.github/workflows/deploy_doc.yml</code>. This publishes the generated HTML into branch <code>documentation</code>.</p> <ol> <li>Review the changes locally and push to <code>dev</code>.</li> <li>When <code>dev</code> gets merged to <code>main</code>, GitHub Actions workflow is     automated to build documentation.</li> </ol>"},{"location":"development/running/","title":"Running a branch","text":""},{"location":"development/running/#with-pip","title":"With PIP","text":"<pre><code>pip install git+https://github.com/{user}/{repo}.git@{branch}\n</code></pre> <p>E.g.:</p> <pre><code>pip install git+https://github.com/ranaroussi/yfinance.git@feature/name\n</code></pre>"},{"location":"development/running/#with-git","title":"With Git","text":"<p>1: Download from GitHub:</p> <pre><code>git clone https://github.com/{user}/{repo}.git\npip install -r ./yfinance/requirements.txt\n</code></pre> <p>Or if a specific branch:</p> <pre><code>git clone -b {branch} https://github.com/{user}/{repo}.git\npip install -r ./yfinance/requirements.txt\n</code></pre> <p>Note: Only do the next part if you are installing globally</p> <p>If you are installing for 1 specific project, then you can skip this step and just <code>git clone</code> in the project directory</p> <ol> <li>Add download location to Python search path</li> </ol> <p>Two different ways, choose one:</p> <p>1)  Add path to <code>PYTHONPATH</code> environment variable</p> <p>2) Add to top of Python file: .. code-block:: python import sys sys.path.insert(0, \"path/to/downloaded/yfinance\")</p> <p>3: Verify</p> <pre><code>import yfinance\nprint(yfinance)\n</code></pre> <p>Output should be:</p> <p><code>\\&lt;module 'yfinance' from 'path/to/downloaded/yfinance/yfinance/\\_\\_init\\_\\_.py'\\&gt;</code></p> <p>If output looks like this then you did step 2 wrong</p> <p><code>\\&lt;module 'yfinance' from '\\.../lib/python3.10/site-packages/yfinance/\\_\\_init\\_\\_.py'\\&gt;</code></p>"},{"location":"development/testing/","title":"Unit Tests","text":"<p>Tests are written using Python's <code>unittest</code> module. Here are some ways to run tests:</p> <ul> <li> <p>Run all price tests:     <code>bash     python -m unittest tests.test_prices</code></p> </li> <li> <p>Run a subset of price tests:     <code>bash     python -m unittest tests.test_prices.TestPriceRepair</code></p> </li> <li> <p>Run a specific test:     <code>bash     python -m unittest tests.test_prices_repair.TestPriceRepair.test_ticker_missing</code></p> </li> <li> <p>General command:     <code>bash     python -m unittest tests.{file}.{class}.{method}</code></p> </li> <li>Run all tests:     <code>bash     python -m unittest discover -s tests</code></li> </ul> <p>Note: The tests are currently failing already</p> <p>Standard result:</p> <p>Failures: 11</p> <p>Errors: 93</p> <p>Skipped: 1</p> <p>See also: See the unittest module for more information.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#overview","title":"Overview","text":"<p>The <code>yfinance</code> package provides easy access to Yahoo! Finance's API to retrieve market data. It includes classes and functions for downloading historical market data, accessing ticker information, managing cache, and more.</p>"},{"location":"reference/#public-api","title":"Public API","text":"<p>The following are the publicly available classes, and functions exposed by the <code>yfinance</code> package:</p> <ul> <li><code>Ticker (yfinance.Ticker)</code>: Class for     accessing single ticker data.</li> <li><code>Tickers (yfinance.Tickers)</code>: Class     for handling multiple tickers.</li> <li><code>Market (yfinance.Market)</code>: Class for     accessing market summary.</li> <li><code>download (yfinance.download)</code>:     Function to download market data for multiple tickers.</li> <li><code>Search (yfinance.Search)</code>: Class for     accessing search results.</li> <li><code>Lookup (yfinance.Lookup)</code>: Class for     looking up tickers.</li> <li><code>WebSocket (yfinance.WebSocket)</code>:     Class for synchronously streaming live market data.</li> <li><code>AsyncWebSocket (yfinance.AsyncWebSocket)</code>: Class for asynchronously streaming live market data.</li> <li><code>Sector (yfinance.Sector)</code>: Domain     class for accessing sector information.</li> <li><code>Industry (yfinance.Industry)</code>:     Domain class for accessing industry information.</li> <li><code>EquityQuery (yfinance.EquityQuery)</code>:     Class to build equity query filters.</li> <li><code>FundQuery (yfinance.FundQuery)</code>:     Class to build fund query filters.</li> <li><code>screen (yfinance.screen)</code>: Run     equity/fund queries.</li> <li><code>enable_debug_mode (yfinance.enable_debug_mode)</code>: Function to enable debug mode for logging.</li> <li> <p><code>set_tz_cache_location (yfinance.set_tz_cache_location)</code>: Function to set the timezone cache location.</p> </li> <li> <p>yfinance.ticker_tickers</p> </li> <li>yfinance.stock</li> <li>yfinance.market</li> <li>yfinance.financials</li> <li>yfinance.analysis</li> <li>yfinance.search</li> <li><code>yfinance.lookup</code></li> <li>yfinance.websocket</li> <li>yfinance.sector_industry</li> <li>yfinance.screener</li> <li>yfinance.functions</li> <li>yfinance.funds_data</li> <li>yfinance.price_history</li> </ul>"},{"location":"reference/yfinance.analysis/","title":"Analysis &amp; Holdings","text":"<p>Module: yfinance.Ticker</p>"},{"location":"reference/yfinance.analysis/#analysis","title":"Analysis","text":"<ul> <li><code>get_recommendations</code> / <code>recommendations</code></li> <li><code>get_recommendations_summary</code> / <code>recommendations_summary</code></li> <li><code>get_upgrades_downgrades</code> / <code>upgrades_downgrades</code></li> <li><code>get_sustainability</code> / <code>sustainability</code></li> <li><code>get_analyst_price_targets</code> / <code>analyst_price_targets</code></li> <li><code>get_earnings_estimate</code> / <code>earnings_estimate</code></li> <li><code>get_revenue_estimate</code> / <code>revenue_estimate</code></li> <li><code>get_earnings_history</code> / <code>earnings_history</code></li> <li><code>get_eps_trend</code> / <code>eps_trend</code></li> <li><code>get_eps_revisions</code> / <code>eps_revisions</code></li> <li><code>get_growth_estimates</code> / <code>growth_estimates</code></li> </ul>"},{"location":"reference/yfinance.analysis/#holdings","title":"Holdings","text":"<ul> <li><code>get_funds_data</code> / <code>funds_data</code></li> </ul> <p>See also: <code>yfinance.scrapers.funds.FundsData</code> - <code>get_major_holders</code> / <code>major_holders</code> - <code>get_institutional_holders</code> / <code>institutional_holders</code> - <code>get_mutualfund_holders</code> / <code>mutualfund_holders</code></p>"},{"location":"reference/yfinance.financials/","title":"Financials","text":"<p>Module: yfinance.Ticker</p> <ul> <li><code>get_income_stmt income_stmt quarterly_income_stmt ttm_income_stmt</code></li> <li><code>get_balance_sheet</code> / <code>balance_sheet</code></li> <li><code>get_cashflow cashflow quarterly_cashflow ttm_cashflow</code></li> <li><code>get_earnings</code> / <code>earnings</code></li> <li><code>calendar</code></li> <li><code>get_earnings_dates</code> / <code>earnings_dates</code></li> <li><code>get_sec_filings</code> / <code>sec_filings</code></li> </ul>"},{"location":"reference/yfinance.functions/","title":"Functions and Utilities","text":"<p>Module: yfinance</p>"},{"location":"reference/yfinance.functions/#download-market-data","title":"Download Market Data","text":"<p>The <code>download</code> function allows you to retrieve market data for multiple tickers at once.</p> <ul> <li><code>download</code></li> </ul>"},{"location":"reference/yfinance.functions/#enable-debug-mode","title":"Enable Debug Mode","text":"<p>Enables logging of debug information for the <code>yfinance</code> package.</p> <ul> <li><code>enable_debug_mode</code></li> </ul>"},{"location":"reference/yfinance.functions/#set-timezone-cache-location","title":"Set Timezone Cache Location","text":"<p>Sets the cache location for timezone data.</p> <ul> <li><code>set_tz_cache_location</code></li> </ul>"},{"location":"reference/yfinance.funds_data/","title":"<code>FundsData</code> class","text":"<p>Module: yfinance.scrapers.funds</p> <ul> <li><code>FundsData</code></li> </ul>"},{"location":"reference/yfinance.market/","title":"Market","text":"<p>Module: yfinance</p>"},{"location":"reference/yfinance.market/#class","title":"Class","text":"<p>The <code>Market</code> class, allows you to access market data in a Pythonic way.</p> <ul> <li><code>Market</code></li> </ul>"},{"location":"reference/yfinance.market/#market-sample-code","title":"Market Sample Code","text":"<pre><code>import yfinance as yf\n\nEUROPE = yf.Market(\"EUROPE\")\n\nstatus = EUROPE.status\nsummary = EUROPE.summary\n</code></pre>"},{"location":"reference/yfinance.market/#markets","title":"Markets","text":"<p>There are 8 different markets available in Yahoo Finance.</p> <ul> <li>US</li> <li> <p>GB</p> </li> <li> <p>ASIA</p> </li> <li> <p>EUROPE</p> </li> <li> <p>RATES</p> </li> <li>COMMODITIES</li> <li>CURRENCIES</li> <li>CRYPTOCURRENCIES</li> </ul>"},{"location":"reference/yfinance.price_history/","title":"<code>PriceHistory</code> class","text":"<p>Module: yfinance.scrapers.history</p> <p>Class: <code>PriceHistory</code></p> <p>Refer to the source code for API details.</p>"},{"location":"reference/yfinance.screener/","title":"Screener &amp; Query","text":"<p>Module: yfinance</p>"},{"location":"reference/yfinance.screener/#query-market-data","title":"Query Market Data","text":"<p>The <code>Sector</code> and <code>Industry</code> modules allow you to access the sector and industry information.</p> <ul> <li><code>EquityQuery FundQuery screen</code></li> </ul> <p>See also: <code>EquityQuery.valid_fields (yfinance.EquityQuery.valid_fields)</code> supported operand values for query <code>EquityQuery.valid_values (yfinance.EquityQuery.valid_values)</code> supported <code>EQ query operand parameters</code> <code>FundQuery.valid_fields (yfinance.FundQuery.valid_fields)</code> supported operand values for query <code>FundQuery.valid_values (yfinance.FundQuery.valid_values)</code> supported <code>EQ query operand parameters</code></p>"},{"location":"reference/yfinance.search/","title":"Search &amp; Lookup","text":"<p>Module: yfinance</p>"},{"location":"reference/yfinance.search/#class","title":"Class","text":"<p>The <code>Search</code> module, allows you to access search data in a Pythonic way.</p> <ul> <li><code>Search</code></li> </ul> <p>The <code>Lookup</code> module, allows you to look up tickers in a Pythonic way.</p> <ul> <li><code>Lookup</code></li> </ul>"},{"location":"reference/yfinance.search/#sample-code","title":"Sample Code","text":"<p>The <code>Search</code> module, allows you to access search data in a Pythonic way.</p> <pre><code>import yfinance as yf\n\n# get list of quotes\nquotes = yf.Search(\"AAPL\", max_results=10).quotes\n\n# get list of news\nnews = yf.Search(\"Google\", news_count=10).news\n\n# get list of related research\nresearch = yf.Search(\"apple\", include_research=True).research\n</code></pre> <p>The <code>Lookup</code> module, allows you to look up tickers in a Pythonic way.</p> <pre><code>import yfinance as yf\n\n# Get All\nall = yf.Lookup(\"AAPL\").all\nall = yf.Lookup(\"AAPL\").get_all(count=100)\n\n# Get Stocks\nstock = yf.Lookup(\"AAPL\").stock\nstock = yf.Lookup(\"AAPL\").get_stock(count=100)\n\n# Get Mutual Funds\nmutualfund = yf.Lookup(\"AAPL\").mutualfund\nmutualfund = yf.Lookup(\"AAPL\").get_mutualfund(count=100)\n\n# Get ETFs\netf = yf.Lookup(\"AAPL\").etf\netf = yf.Lookup(\"AAPL\").get_etf(count=100)\n\n# Get Indices\nindex = yf.Lookup(\"AAPL\").index\nindex = yf.Lookup(\"AAPL\").get_index(count=100)\n\n# Get Futures\nfuture = yf.Lookup(\"AAPL\").future\nfuture = yf.Lookup(\"AAPL\").get_future(count=100)\n\n# Get Currencies\ncurrency = yf.Lookup(\"AAPL\").currency\ncurrency = yf.Lookup(\"AAPL\").get_currency(count=100)\n\n# Get Cryptocurrencies\ncryptocurrency = yf.Lookup(\"AAPL\").cryptocurrency\ncryptocurrency = yf.Lookup(\"AAPL\").get_cryptocurrency(count=100)\n</code></pre>"},{"location":"reference/yfinance.sector_industry/","title":"Sector and Industry","text":"<p>Module: yfinance</p>"},{"location":"reference/yfinance.sector_industry/#sector-class","title":"Sector class","text":"<p>The <code>Sector</code> and <code>Industry</code> modules provide access to the Sector and Industry information.</p> <ul> <li><code>Sector</code> / <code>Industry</code></li> </ul> <p>See also: <code>Sector.industries (yfinance.Sector.industries)</code> Map of sector and industry ## Sample Code To initialize, use the relevant sector or industry key as below. ``` python import yfinance as yf</p> <p>tech = yf.Sector('technology') software = yf.Industry('software-infrastructure')</p>"},{"location":"reference/yfinance.sector_industry/#common-information","title":"Common information","text":"<p>tech.key tech.name tech.symbol tech.ticker tech.overview tech.top_companies tech.research_reports</p>"},{"location":"reference/yfinance.sector_industry/#sector-information","title":"Sector information","text":"<p>tech.top_etfs tech.top_mutual_funds tech.industries</p>"},{"location":"reference/yfinance.sector_industry/#industry-information","title":"Industry information","text":"<p>software.sector_key software.sector_name software.top_performing_companies software.top_growth_companies</p> <pre><code>\nThe modules can be chained with Ticker as below.\n\n``` python\nimport yfinance as yf\n# Ticker to Sector and Industry\nmsft = yf.Ticker('MSFT')\ntech = yf.Sector(msft.info.get('sectorKey'))\nsoftware = yf.Industry(msft.info.get('industryKey'))\n\n# Sector and Industry to Ticker\ntech_ticker = tech.ticker\ntech_ticker.info\nsoftware_ticker = software.ticker\nsoftware_ticker.history()\n</code></pre>"},{"location":"reference/yfinance.stock/","title":"Stock","text":"<p>Module: yfinance.Ticker</p>"},{"location":"reference/yfinance.stock/#ticker-stock-methods","title":"Ticker stock methods","text":"<ul> <li><code>get_isin</code> / <code>isin</code></li> <li><code>history</code></li> </ul> <p>See also: <code>yfinance.scrapers.history.PriceHistory.history</code> Documentation for history ../advanced/price_repair :   Documentation for price repair</p> <ul> <li><code>get_history_metadata</code></li> <li><code>get_dividends</code> / <code>dividends</code></li> <li><code>get_splits</code> / <code>splits</code></li> <li><code>get_actions</code> / <code>actions</code></li> <li><code>get_capital_gains</code> / <code>capital_gains</code></li> <li><code>get_shares_full</code></li> <li><code>get_info</code> / <code>info</code></li> <li><code>get_fast_info</code> / <code>fast_info</code></li> <li><code>get_news</code> / <code>news</code></li> </ul>"},{"location":"reference/yfinance.ticker_tickers/","title":"Ticker and Tickers","text":"<p>Module: yfinance</p>"},{"location":"reference/yfinance.ticker_tickers/#class","title":"Class","text":"<p>The <code>Ticker</code> module, allows you to access ticker data in a Pythonic way.</p> <ul> <li><code>Ticker</code> / <code>Tickers</code></li> </ul>"},{"location":"reference/yfinance.ticker_tickers/#ticker-sample-code","title":"Ticker Sample Code","text":"<p>The <code>Ticker</code> module, allows you to access ticker data in a Pythonic way.</p> <pre><code>import yfinance as yf\n\ndat = yf.Ticker(\"MSFT\")\n\n# get historical market data\ndat.history(period='1mo')\n\n# options\ndat.option_chain(dat.options[0]).calls\n\n# get financials\ndat.balance_sheet\ndat.quarterly_income_stmt\n\n# dates\ndat.calendar\n\n# general info\ndat.info\n\n# analysis\ndat.analyst_price_targets\n\n# websocket\ndat.live()\n</code></pre> <p>To initialize multiple <code>Ticker</code> objects, use</p> <pre><code>import yfinance as yf\n\ntickers = yf.Tickers('msft aapl goog')\n\n# access each ticker using (example)\ntickers.tickers['MSFT'].info\ntickers.tickers['AAPL'].history(period=\"1mo\")\ntickers.tickers['GOOG'].actions\n\n# websocket\ntickers.live()\n</code></pre> <p>For tickers that are ETFs/Mutual Funds, <code>Ticker.funds_data</code> provides access to fund related data.</p> <p>Funds' Top Holdings and other data with category average is returned as <code>pd.DataFrame</code>.</p> <pre><code>import yfinance as yf\nspy = yf.Ticker('SPY')\ndata = spy.funds_data\n\n# show fund description\ndata.description\n\n# show operational information\ndata.fund_overview\ndata.fund_operations\n\n# show holdings related information\ndata.asset_classes\ndata.top_holdings\ndata.equity_holdings\ndata.bond_holdings\ndata.bond_ratings\ndata.sector_weightings\n</code></pre> <p>If you want to use a proxy server for downloading data, use:</p> <pre><code>import yfinance as yf\n\nmsft = yf.Ticker(\"MSFT\")\n\nmsft.history(..., proxy=\"PROXY_SERVER\")\nmsft.get_actions(proxy=\"PROXY_SERVER\")\nmsft.get_dividends(proxy=\"PROXY_SERVER\")\nmsft.get_splits(proxy=\"PROXY_SERVER\")\nmsft.get_capital_gains(proxy=\"PROXY_SERVER\")\nmsft.get_balance_sheet(proxy=\"PROXY_SERVER\")\nmsft.get_cashflow(proxy=\"PROXY_SERVER\")\nmsft.option_chain(..., proxy=\"PROXY_SERVER\")\n...\n</code></pre> <p>To initialize multiple <code>Ticker</code> objects, use <code>Tickers</code> module</p> <pre><code>import yfinance as yf\n\ntickers = yf.Tickers('msft aapl goog')\n\n# access each ticker using (example)\ntickers.tickers['MSFT'].info\ntickers.tickers['AAPL'].history(period=\"1mo\")\ntickers.tickers['GOOG'].actions\n\n# websocket\ntickers.live()\n</code></pre>"},{"location":"reference/yfinance.websocket/","title":"WebSocket","text":"<p>Module: yfinance</p> <p>The <code>WebSocket</code> module allows you to stream live price data from Yahoo Finance using both synchronous and asynchronous clients.</p>"},{"location":"reference/yfinance.websocket/#classes","title":"Classes","text":"<ul> <li><code>WebSocket</code> / <code>AsyncWebSocket</code></li> </ul>"},{"location":"reference/yfinance.websocket/#synchronous-websocket","title":"Synchronous WebSocket","text":"<p>The <code>WebSocket</code> class provides a synchronous interface for subscribing to price updates.</p> <p>Sample Code:</p> <pre><code>import yfinance as yf\n\n# define your message callback\ndef message_handler(message):\n    print(\"Received message:\", message)\n\n# =======================\n# With Context Manager\n# =======================\nwith yf.WebSocket() as ws:\n    ws.subscribe([\"AAPL\", \"BTC-USD\"])\n    ws.listen(message_handler)\n\n# =======================\n# Without Context Manager\n# =======================\nws = yf.WebSocket()\nws.subscribe([\"AAPL\", \"BTC-USD\"])\nws.listen(message_handler)\n</code></pre>"},{"location":"reference/yfinance.websocket/#asynchronous-websocket","title":"Asynchronous WebSocket","text":"<p>The <code>AsyncWebSocket</code> class provides an asynchronous interface for subscribing to price updates.</p> <p>Sample Code:</p> <pre><code>import asyncio\nimport yfinance as yf\n\n# define your message callback\ndef message_handler(message):\n    print(\"Received message:\", message)\n\nasync def main():\n    # =======================\n    # With Context Manager\n    # =======================\n    async with yf.AsyncWebSocket() as ws:\n        await ws.subscribe([\"AAPL\", \"BTC-USD\"])\n        await ws.listen()\n\n    # =======================\n    # Without Context Manager\n    # =======================\n    ws = yf.AsyncWebSocket()\n    await ws.subscribe([\"AAPL\", \"BTC-USD\"])\n    await ws.listen()\n\nasyncio.run(main())\n</code></pre> <p>Note: If you're running asynchronous code in a Jupyter notebook, you may encounter issues with event loops. To resolve this, you need to import and apply <code>nest_asyncio</code> to allow nested event loops.</p> <p>Add the following code before running asynchronous operations:</p> <p><code>python import nest_asyncio nest_asyncio.apply()</code></p>"},{"location":"tutorial/","title":"Tutorial: yfinance","text":"<p><code>yfinance</code> is a popular Python library that makes it incredibly easy to download historical and real-time financial market data from Yahoo Finance. The core of the library is the <code>Ticker</code> object, which acts as a gateway to all information for a specific stock, like <code>MSFT</code>. You can use it to fetch everything from historical prices to financial statements, or even download data for multiple tickers at once.</p> <p>Source Repository: https://github.com/ranaroussi/yfinance</p> <pre><code>flowchart TD\n    A0[\"Ticker Object\n\"]\n    A1[\"YfData (Data Fetching Layer)\n\"]\n    A2[\"Data Scrapers\n\"]\n    A3[\"Multi-Ticker Operations\n\"]\n    A4[\"Domain Entities (Sector, Industry, Market)\n\"]\n    A5[\"Screener &amp; Query Objects\n\"]\n    A6[\"WebSocket (Live Data Streaming)\n\"]\n    A0 -- \"Uses for data fetching\" --&gt; A1\n    A0 -- \"Delegates parsing to\" --&gt; A2\n    A0 -- \"Initiates live stream with\" --&gt; A6\n    A2 -- \"Uses for data fetching\" --&gt; A1\n    A3 -- \"Orchestrates multiple\" --&gt; A0\n    A4 -- \"Uses for data fetching\" --&gt; A1\n    A5 -- \"Executes queries via\" --&gt; A1\n</code></pre>"},{"location":"tutorial/#chapters","title":"Chapters","text":"<ol> <li>Ticker Object </li> <li>Multi-Ticker Operations </li> <li>Screener &amp; Query Objects </li> <li>WebSocket (Live Data Streaming) </li> <li>Domain Entities (Sector, Industry, Market) </li> <li>YfData (Data Fetching Layer) </li> <li>Data Scrapers </li> </ol> <p>Generated by Codebase Knowledge Builder</p>"},{"location":"tutorial/01_ticker_object_/","title":"Chapter 1: The Ticker Object","text":"<p>Welcome to your journey with <code>yfinance</code>! If you've ever wanted to get financial data\u2014like stock prices for your favorite companies\u2014you're in the right place. In this first chapter, we'll meet the most fundamental building block of the <code>yfinance</code> library: the <code>Ticker</code> object.</p>"},{"location":"tutorial/01_ticker_object_/#the-goal-getting-data-for-one-company","title":"The Goal: Getting Data for One Company","text":"<p>Imagine you want to start analyzing Microsoft. You might ask questions like: *   What was its stock price last month? *   What's the company's address? *   What do its financial statements look like?</p> <p>The <code>Ticker</code> object is your tool to answer all these questions. Think of it as a dedicated digital folder for a single financial instrument, like a stock. For Microsoft, its stock symbol (or \"ticker\") is <code>MSFT</code>. Let's create a <code>Ticker</code> object for it.</p>"},{"location":"tutorial/01_ticker_object_/#creating-your-first-ticker-object","title":"Creating Your First Ticker Object","text":"<p>Getting started is as simple as importing the library and creating an object. All you need is the company's ticker symbol.</p> <pre><code>import yfinance as yf\n\n# Create a Ticker object for Microsoft\nmsft = yf.Ticker(\"MSFT\")\n</code></pre> <p>That's it! You've just created <code>msft</code>, a gateway to all sorts of data about Microsoft.</p> <p>An important thing to understand is that this line of code doesn't download any data yet. It just prepares the gateway. This is called \"lazy loading,\" and it's very efficient because we only fetch the data we explicitly ask for.</p>"},{"location":"tutorial/01_ticker_object_/#asking-for-specific-information","title":"Asking for Specific Information","text":"<p>Now that we have our <code>msft</code> object, we can start asking it for information.</p>"},{"location":"tutorial/01_ticker_object_/#1-getting-historical-prices","title":"1. Getting Historical Prices","text":"<p>Let's ask for the stock price history for the last month. We use the <code>.history()</code> method for this.</p> <pre><code># Get historical market data for the last month\nhist = msft.history(period=\"1mo\")\n\nprint(hist.head()) # Print the first 5 rows\n</code></pre> <p>What you'll see:</p> <p>This command fetches the daily Open, High, Low, and Close prices, along with the trading Volume for the past month. The result is a <code>pandas</code> DataFrame, which is like a powerful spreadsheet perfect for data analysis.</p> <pre><code>                  Open        High         Low       Close      Volume  Dividends  Stock Splits\nDate\n2023-10-02  315.040002  319.649994  314.880005  318.920013    20803300        0.0           0.0\n2023-10-03  317.380005  318.510010  313.540009  315.609985    19927800        0.0           0.0\n2023-10-04  316.079987  321.739990  315.829987  321.549988    21340100        0.0           0.0\n2023-10-05  321.059998  322.010010  318.010010  321.649994    19022600        0.0           0.0\n2023-10-06  319.339996  330.019989  319.019989  329.890015    25400600        0.0           0.0\n</code></pre>"},{"location":"tutorial/01_ticker_object_/#2-getting-general-company-info","title":"2. Getting General Company Info","text":"<p>What if you want basic information, like the company's industry or a summary of its business? The <code>.info</code> property gives you this.</p> <pre><code># Get general company information\ninfo = msft.info\n\nprint(info['longName'])\nprint(info['sector'])\nprint(info['website'])\n</code></pre> <p>What you'll see:</p> <p>This returns a Python dictionary filled with details. We've just printed the company's full name, its sector, and its website.</p> <pre><code>Microsoft Corporation\nTechnology\nhttps://www.microsoft.com\n</code></pre>"},{"location":"tutorial/01_ticker_object_/#3-getting-financial-statements","title":"3. Getting Financial Statements","text":"<p>You can also pull official financial reports like the balance sheet.</p> <pre><code># Get the company's balance sheet\nbalance_sheet = msft.balance_sheet\n\nprint(balance_sheet)\n</code></pre> <p>What you'll see:</p> <p>This returns another DataFrame containing Microsoft's assets, liabilities, and equity over the last few years. It's a goldmine for fundamental analysis!</p>"},{"location":"tutorial/01_ticker_object_/#whats-happening-under-the-hood","title":"What's Happening Under the Hood?","text":"<p>You might be wondering how <code>yfinance</code> does this. The process is quite simple and illustrates the power of lazy loading.</p> <ol> <li>Creation: When you run <code>msft = yf.Ticker(\"MSFT\")</code>, you create an object that knows it's responsible for the \"MSFT\" ticker, but it doesn't do anything else.</li> <li>Request: When you call a method like <code>msft.history()</code>, the <code>Ticker</code> object springs into action.</li> <li>Fetch: It sends a request over the internet to Yahoo Finance's servers, asking specifically for the historical data for \"MSFT\".</li> <li>Return: Yahoo Finance sends the data back, and <code>yfinance</code> neatly packages it into a DataFrame for you.</li> </ol> <p>This flow ensures that you only use your internet connection and processing power when you absolutely need to.</p> <p>Here is a diagram illustrating the process when you ask for historical data:</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant YF as yfinance Library\n    participant TO as Ticker Object\n    participant YAPI as Yahoo Finance API\n\n    U-&gt;&gt;YF: yf.Ticker(\"MSFT\")\n    YF--&gt;&gt;TO: Create Ticker(\"MSFT\") object\n    TO--&gt;&gt;U: Return msft object\n    Note right of U: No data has been downloaded yet!\n\n    U-&gt;&gt;TO: msft.history()\n    TO-&gt;&gt;YAPI: Request historical data for \"MSFT\"\n    YAPI--&gt;&gt;TO: Return raw historical data\n    TO-&gt;&gt;YF: Process data into a DataFrame\n    YF--&gt;&gt;U: Return DataFrame\n</code></pre> <p>If you look inside the <code>yfinance</code> source code, specifically in the file <code>yfinance/base.py</code>, you'll see the <code>__init__</code> method of the <code>TickerBase</code> class. It's quite simple!</p> <pre><code># From yfinance/base.py\n\nclass TickerBase:\n    def __init__(self, ticker, session=None, proxy=_SENTINEL_):\n        # ... some setup code ...\n        self.ticker = ticker.upper()\n        # ... more setup, but no heavy data fetching! ...\n</code></pre> <p>This confirms that creating a <code>Ticker</code> is a lightweight operation. The real work happens inside methods like <code>history()</code>, which internally call functions to fetch data on demand. This \"just-in-time\" data fetching is what makes the <code>Ticker</code> object so fast and efficient to use.</p>"},{"location":"tutorial/01_ticker_object_/#conclusion","title":"Conclusion","text":"<p>You've just learned about the most important object in <code>yfinance</code>: the <code>Ticker</code>.</p> <ul> <li>What it is: A gateway to all data for a single financial symbol (e.g., \"MSFT\").</li> <li>How it works: It uses a \"lazy-loading\" approach, meaning it only fetches data when you ask for it.</li> <li>How to use it: You create it with <code>yf.Ticker(\"SYMBOL\")</code> and then access data through its methods (<code>.history()</code>) and properties (<code>.info</code>, <code>.balance_sheet</code>).</li> </ul> <p>The <code>Ticker</code> object is your go-to tool for deep-diving into a single company. But what if you want to compare Microsoft to Apple and Google all at once? For that, we need a way to handle multiple tickers efficiently.</p> <p>That's exactly what we'll cover in the next chapter on Multi-Ticker Operations.</p> <p>Generated by Codebase Knowledge Builder</p>"},{"location":"tutorial/02_multi_ticker_operations_/","title":"Chapter 2: Multi-Ticker Operations","text":"<p>In Chapter 1: The Ticker Object, we learned how to get detailed information for a single company using the <code>Ticker</code> object. This is perfect for a deep dive into one stock. But what if you want to compare the performance of several major tech companies, like Microsoft, Apple, and Google? Fetching them one by one would be slow and repetitive.</p> <p>This is where multi-ticker operations come in. <code>yfinance</code> provides powerful tools designed to fetch data for many stocks at once, saving you time and code.</p>"},{"location":"tutorial/02_multi_ticker_operations_/#the-goal-comparing-multiple-companies","title":"The Goal: Comparing Multiple Companies","text":"<p>Let's set a simple goal: Get the last month's stock price history for Microsoft (<code>MSFT</code>), Apple (<code>AAPL</code>), and Google (<code>GOOG</code>) all in one go.</p> <p>Doing this one by one would look like this:</p> <pre><code># The slow, one-by-one way (don't do this!)\nmsft_hist = yf.Ticker(\"MSFT\").history(period=\"1mo\")\naapl_hist = yf.Ticker(\"AAPL\").history(period=\"1mo\")\ngoog_hist = yf.Ticker(\"GOOG\").history(period=\"1mo\")\n# Now we have three separate tables to manage...\n</code></pre> <p>This works, but it's inefficient. If you have 100 stocks, you'd be making 100 separate requests one after another. <code>yfinance</code> gives us two much better ways: the <code>download()</code> function and the <code>Tickers</code> class.</p>"},{"location":"tutorial/02_multi_ticker_operations_/#1-the-quickest-way-yfdownload","title":"1. The Quickest Way: <code>yf.download()</code>","text":"<p>Think of <code>yf.download()</code> as a highly efficient assistant. You give it a list of items, and it goes and fetches all of them simultaneously, returning everything to you in a single, neatly organized table. It's the fastest way to get historical price data for multiple stocks.</p> <p>Let's use it to achieve our goal. All you need to do is provide the ticker symbols in a single string, separated by spaces.</p> <pre><code>import yfinance as yf\n\n# Download historical data for multiple tickers at once\ndata = yf.download(\"MSFT AAPL GOOG\", period=\"1mo\")\n\nprint(data.head())\n</code></pre> <p>What you'll see:</p> <p>Instead of three separate tables, you get one master <code>pandas</code> DataFrame. The columns are neatly organized by stock price metrics (like <code>Close</code>, <code>Open</code>) and then by ticker symbol.</p> <pre><code>                  Adj Close                           Close  ...        Volume\n                       AAPL        GOOG        MSFT    AAPL  ...        GOOG      MSFT\nDate                                                       ...\n2023-10-02       173.750000  132.539993  315.750000   173.75  ...    51351100  20803300\n2023-10-03       172.399994  132.050003  314.730011   172.40  ...    50073500  19927800\n2023-10-04       173.660004  134.940002  318.899994   173.66  ...    52036500  21340100\n2023-10-05       174.910004  134.800003  319.290009   174.91  ...    44362100  19022600\n2023-10-06       177.490005  137.960007  327.260010   177.49  ...    56758400  25400600\n</code></pre> <p>Notice the columns have two levels. For example, to get just the closing prices for all stocks, you can easily select the <code>Close</code> column.</p> <pre><code># Get just the closing prices\nclose_prices = data['Close']\n\nprint(close_prices.head())\n</code></pre> <p>What you'll see:</p> <pre><code>                  AAPL        GOOG        MSFT\nDate\n2023-10-02  173.750000  132.539993  315.750000\n2023-10-03  172.399994  132.050003  314.730011\n2023-10-04  173.660004  134.940002  318.899994\n2023-10-05  174.910004  134.800003  319.290009\n2023-10-06  177.490005  137.960007  327.260010\n</code></pre> <p>This is incredibly powerful for comparing stocks or calculating portfolio returns. <code>yf.download()</code> is your go-to function for bulk historical data.</p>"},{"location":"tutorial/02_multi_ticker_operations_/#2-the-organizer-yftickers","title":"2. The Organizer: <code>yf.Tickers</code>","text":"<p>What if you want more than just historical prices? Maybe you want the <code>.info</code> for Apple, the <code>.balance_sheet</code> for Google, and the <code>.history()</code> for Microsoft.</p> <p>The <code>Tickers</code> class (notice the \"s\" at the end) is designed for this. It acts as a container or a folder that holds multiple <code>Ticker</code> objects, allowing you to manage them as a group.</p> <pre><code>import yfinance as yf\n\n# Create a Tickers object\ntickers = yf.Tickers('msft aapl goog')\n</code></pre> <p>This line creates an object that holds three individual <code>Ticker</code> objects. Now you can easily access each one.</p> <pre><code># Access the Ticker object for Apple\naapl_ticker = tickers.tickers['AAPL']\n\n# Now you can use it just like we did in Chapter 1\nprint(aapl_ticker.info['longName'])\n</code></pre> <p>What you'll see:</p> <pre><code>Apple Inc.\n</code></pre> <p>The <code>Tickers</code> object also has its own <code>.history()</code> method, which conveniently calls <code>yf.download()</code> for you.</p> <pre><code># Get history for all tickers in the group\nhist = tickers.history(period=\"1mo\")\n\n# The output is grouped by ticker first\nprint(hist.head())\n</code></pre> <p>What you'll see:</p> <p>The output is similar to <code>yf.download()</code>, but the columns are grouped by ticker first by default.</p> <pre><code>          AAPL                                         ...         MSFT\n          Open        High         Low       Close     ...         High         Low       Close   Volume\nDate                                                   ...\n2023-10-02  171.220001  174.300003  170.929993  173.750000     ...   319.649994  314.880005  318.920013  20803300\n...\n</code></pre> <p>When should you use <code>download</code> vs. <code>Tickers</code>?</p> <ul> <li>Use <code>yf.download()</code> when you only need historical price data for many stocks. It's direct and fast.</li> <li>Use <code>yf.Tickers</code> when you need to manage a group of stocks and want to access different types of data for each one (e.g., <code>.info</code>, <code>.financials</code>, etc.).</li> </ul>"},{"location":"tutorial/02_multi_ticker_operations_/#whats-happening-under-the-hood-the-magic-of-threading","title":"What's Happening Under the Hood? The Magic of Threading","text":"<p>How does <code>yf.download(\"MSFT AAPL GOOG\")</code> get data so much faster than calling <code>yf.Ticker()</code> three times in a row? The secret is multithreading.</p> <p>Imagine you have to get three books from a library. The one-by-one approach is: 1.  Go to the \"M\" section, find the Microsoft book, and bring it back. 2.  Go to the \"A\" section, find the Apple book, and bring it back. 3.  Go to the \"G\" section, find the Google book, and bring it back.</p> <p>You spend a lot of time walking back and forth.</p> <p>The <code>yf.download()</code> approach is like hiring three assistants (threads): 1.  You tell Assistant 1 to get the Microsoft book. 2.  At the same time, you tell Assistant 2 to get the Apple book. 3.  And at the same time, you tell Assistant 3 to get the Google book.</p> <p>They all work in parallel, and the total time it takes is only as long as the slowest assistant. This is much more efficient!</p> <p>Here is a diagram showing how <code>yf.download</code> works:</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant DL as yf.download()\n    participant W1 as Worker 1 (for MSFT)\n    participant W2 as Worker 2 (for AAPL)\n    participant YAPI as Yahoo Finance API\n\n    U-&gt;&gt;DL: yf.download(\"MSFT AAPL\")\n    Note over DL: Starts multiple threads\n    DL-&gt;&gt;W1: Get history for \"MSFT\"\n    DL-&gt;&gt;W2: Get history for \"AAPL\"\n\n    W1-&gt;&gt;YAPI: Request \"MSFT\" data\n    W2-&gt;&gt;YAPI: Request \"AAPL\" data\n    Note left of YAPI: Requests happen in parallel!\n\n    YAPI--&gt;&gt;W1: Return MSFT data\n    YAPI--&gt;&gt;W2: Return AAPL data\n\n    W1--&gt;&gt;DL: Store MSFT DataFrame\n    W2--&gt;&gt;DL: Store AAPL DataFrame\n    Note over DL: Waits for all workers to finish\n\n    DL-&gt;&gt;U: Return one combined DataFrame\n</code></pre> <p>If you peek inside the <code>yfinance</code> source code, specifically in <code>yfinance/multi.py</code>, you'll find the <code>download</code> function. It loops through your list of tickers and kicks off a threaded task for each one.</p> <pre><code># Simplified from yfinance/multi.py\n\n# A loop inside the download() function\nfor i, ticker in enumerate(tickers):\n    _download_one_threaded(ticker, ...)\n</code></pre> <p>The <code>_download_one_threaded</code> function is where the magic happens. It runs in its own thread and, at its core, it simply creates a Ticker Object and calls its <code>.history()</code> method.</p> <pre><code># Simplified from yfinance/multi.py\n\ndef _download_one(ticker, ...):\n    # It creates a Ticker object just like we did in Chapter 1!\n    data = Ticker(ticker).history(...)\n    # It then saves the result to a shared place\n    shared._DFS[ticker.upper()] = data\n</code></pre> <p>Each thread fetches data for its assigned ticker and stores the result in a shared dictionary (<code>shared._DFS</code>). Once all the threads have finished, the <code>download</code> function combines all the individual DataFrames into the single, master DataFrame that it returns to you.</p> <p>This clever use of threading makes <code>yfinance</code> incredibly fast for gathering large datasets.</p>"},{"location":"tutorial/02_multi_ticker_operations_/#conclusion","title":"Conclusion","text":"<p>You've now unlocked the ability to work with multiple stocks at once, a crucial skill for any real-world financial analysis.</p> <ul> <li>What you learned: How to fetch data for multiple tickers efficiently.</li> <li>Key Tools:<ul> <li><code>yf.download()</code>: Your high-speed tool for bulk-downloading historical price data.</li> <li><code>yf.Tickers</code>: Your organizer for managing a group of <code>Ticker</code> objects to get varied types of data.</li> </ul> </li> <li>The Big Idea: <code>yfinance</code> uses multithreading to run multiple data requests in parallel, which is significantly faster than doing them one by one.</li> </ul> <p>So far, we've assumed you already know which tickers you want to analyze. But what if you want to discover new ones? For instance, how would you find all technology stocks based in the USA with a high dividend yield? For that, you'll need a way to screen and search for stocks.</p> <p>That's precisely what we'll explore in the next chapter on Screener &amp; Query Objects.</p> <p>Generated by Codebase Knowledge Builder</p>"},{"location":"tutorial/03_screener___query_objects_/","title":"Chapter 3: Screener &amp; Query Objects","text":"<p>In the previous chapters on the Ticker Object and Multi-Ticker Operations, we focused on getting data for stocks we already knew by name, like \"MSFT\" or \"AAPL\". But what if you don't know which stocks you're interested in yet? What if you want to discover new investment opportunities?</p> <p>This is where the screener comes in. It's like a powerful search engine for the entire stock market, allowing you to find companies that match your specific criteria.</p>"},{"location":"tutorial/03_screener___query_objects_/#the-goal-discovering-new-stocks","title":"The Goal: Discovering New Stocks","text":"<p>Imagine you're an investor interested in finding stable, US-based technology companies. You might have a specific question like:</p> <p>\"Show me all technology stocks in the United States with a market capitalization between $10 billion and $100 billion.\"</p> <p>This isn't something you can answer by looking up a single ticker. You need a tool to scan the market for you. Let's see how <code>yfinance</code> helps us do just that.</p>"},{"location":"tutorial/03_screener___query_objects_/#1-the-easy-way-predefined-screeners","title":"1. The Easy Way: Predefined Screeners","text":"<p>Yahoo Finance already has several common searches saved for you, like \"Day Gainers\" or \"Growth Technology Stocks\". <code>yfinance</code> gives you direct access to these.</p> <p>Let's try running the \"growth_technology_stocks\" screener. All we need is the <code>screen()</code> function.</p> <pre><code>import yfinance as yf\n\n# Run a predefined screener for growth technology stocks\nresults = yf.screen('growth_technology_stocks')\n\n# The result is a dictionary, let's look at the first 5 stocks found\nprint(results['quotes'][:5])\n</code></pre> <p>What you'll see:</p> <p>You'll get back a list of stocks that match Yahoo's definition of a \"growth technology stock,\" neatly packaged with their ticker symbols and names.</p> <pre><code>[{'symbol': 'PANW', 'longName': 'Palo Alto Networks, Inc.'}, {'symbol': 'AMD', 'longName': 'Advanced Micro Devices, Inc.'}, {'symbol': 'ADBE', 'longName': 'Adobe Inc.'}, {'symbol': 'ACN', 'longName': 'Accenture plc'}, {'symbol': 'UBER', 'longName': 'Uber Technologies, Inc.'}]\n</code></pre> <p>This is great for common searches, but it doesn't answer our specific question about market cap. For that, we need to build our own custom query.</p>"},{"location":"tutorial/03_screener___query_objects_/#2-the-powerful-way-building-your-own-query","title":"2. The Powerful Way: Building Your Own Query","text":"<p>To build a custom search, we need to give <code>yfinance</code> a set of precise instructions. We do this using <code>EquityQuery</code> objects. Think of an <code>EquityQuery</code> as a single rule or filter in our search.</p> <p>Let's build our query piece by piece to answer our goal.</p>"},{"location":"tutorial/03_screener___query_objects_/#step-1-create-a-rule-for-the-region","title":"Step 1: Create a rule for the region","text":"<p>First, we want stocks in the United States. The rule for this looks like <code>['region', 'eq', 'us']</code>, which means \"region equals 'us'\". We wrap this in an <code>EquityQuery</code> object.</p> <pre><code>from yfinance import EquityQuery\n\n# Rule 1: The company's region must be the United States.\nrule1 = EquityQuery('eq', ['region', 'us'])\n</code></pre>"},{"location":"tutorial/03_screener___query_objects_/#step-2-create-a-rule-for-the-sector","title":"Step 2: Create a rule for the sector","text":"<p>Next, we only want technology companies. The rule is <code>['sector', 'eq', 'Technology']</code>.</p> <pre><code># Rule 2: The company's sector must be 'Technology'.\nrule2 = EquityQuery('eq', ['sector', 'Technology'])\n</code></pre>"},{"location":"tutorial/03_screener___query_objects_/#step-3-create-a-rule-for-the-market-cap","title":"Step 3: Create a rule for the market cap","text":"<p>Finally, we want a market cap between $10 billion and $100 billion. The operator for \"between\" is <code>btwn</code>.</p> <pre><code># Rule 3: Market cap must be between $10B and $100B.\n# Note: We use the full numbers, not abbreviations like \"$10B\".\nrule3 = EquityQuery('btwn', ['intradaymarketcap', 10000000000, 100000000000])\n</code></pre>"},{"location":"tutorial/03_screener___query_objects_/#step-4-combine-the-rules","title":"Step 4: Combine the rules","text":"<p>Now we have three separate rules. We need to tell the screener to find stocks that match all three of them. We do this by creating one final <code>EquityQuery</code> that combines them with an <code>and</code> operator.</p> <pre><code># Combine all rules with 'and'\nfinal_query = EquityQuery('and', [rule1, rule2, rule3])\n\nprint(final_query)\n</code></pre> <p>This <code>final_query</code> object now represents our complete set of instructions. Printing it shows the nested structure of our search.</p>"},{"location":"tutorial/03_screener___query_objects_/#step-5-run-the-custom-screen","title":"Step 5: Run the custom screen","text":"<p>We're ready! We pass our custom <code>final_query</code> object to the <code>screen()</code> function.</p> <pre><code># Run the screen with our custom query\nresults = yf.screen(final_query)\n\n# Let's see the first 5 stocks it found\nprint(results['quotes'][:5])\n</code></pre> <p>What you'll see:</p> <p>Success! The output is a list of technology stocks in the US that fit our specific market cap criteria.</p> <pre><code>[{'symbol': 'ADSK', 'longName': 'Autodesk, Inc.'}, {'symbol': 'TEAM', 'longName': 'Atlassian Corporation'}, {'symbol': 'FTNT', 'longName': 'Fortinet, Inc.'}, {'symbol': 'ANET', 'longName': 'Arista Networks, Inc.'}, {'symbol': 'PAYX', 'longName': 'Paychex, Inc.'}]\n</code></pre> <p>You've just become a data detective, programming your own search to find hidden gems in the market! There are also <code>FundQuery</code> objects for searching mutual funds and many more operators (<code>lt</code> for less than, <code>gt</code> for greater than) to explore.</p>"},{"location":"tutorial/03_screener___query_objects_/#whats-happening-under-the-hood","title":"What's Happening Under the Hood?","text":"<p>Building a query might seem like magic, but it's a very logical process. You are essentially building a structured request that <code>yfinance</code> translates for Yahoo's servers.</p> <ol> <li>Build: When you create an <code>EquityQuery</code> like <code>EquityQuery('eq', ['region', 'us'])</code>, you are creating a Python object that holds your rule (<code>eq</code>, <code>region</code>, <code>us</code>) in a structured way.</li> <li>Translate: When you pass this object to <code>yf.screen()</code>, it calls a special method on your query object called <code>.to_dict()</code>. This method converts your Python object into a JSON format that the Yahoo Finance API can understand.</li> <li>Request: <code>yfinance</code> sends this JSON \"instruction sheet\" to the Yahoo Finance screener API.</li> <li>Return: The API runs the search on its massive database and sends back a list of matching stocks, which <code>yfinance</code> then gives to you.</li> </ol> <p>Here's a diagram of the process:</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant EQ as EquityQuery Object\n    participant S as yf.screen()\n    participant YAPI as Yahoo Screener API\n\n    U-&gt;&gt;EQ: Create query objects (rules)\n    EQ--&gt;&gt;U: Return final_query object\n\n    U-&gt;&gt;S: screen(final_query)\n    S-&gt;&gt;EQ: final_query.to_dict()\n    EQ--&gt;&gt;S: Return JSON-like dictionary\n    S-&gt;&gt;YAPI: POST request with JSON query\n    YAPI--&gt;&gt;S: Return list of matching stocks\n    S--&gt;&gt;U: Return parsed results\n</code></pre> <p>If we look inside the <code>yfinance</code> source code, we can see this exact process. The <code>EquityQuery</code> class in <code>yfinance/screener/query.py</code> is responsible for holding your rules.</p> <pre><code># Simplified from yfinance/screener/query.py\n\nclass QueryBase:\n    def __init__(self, operator, operand):\n        # ... validation code ...\n        self.operator = operator\n        self.operands = operand\n\n    # This is the key translation step!\n    def to_dict(self) -&gt; Dict:\n        return {\n            \"operator\": self.operator,\n            \"operands\": [o.to_dict() if isinstance(o, QueryBase) else o for o in self.operands]\n        }\n</code></pre> <p>Then, the <code>screen</code> function in <code>yfinance/screener/screener.py</code> takes your query object, calls <code>.to_dict()</code>, and sends it off.</p> <pre><code># Simplified from yfinance/screener/screener.py\n\ndef screen(query, ...):\n    # ... setup code ...\n\n    if isinstance(query, QueryBase):\n        post_query = {}\n        # Here's where it translates your object!\n        post_query['query'] = query.to_dict()\n\n        # It then sends this 'post_query' to Yahoo's API\n        response = _data.post(_SCREENER_URL_, body=post_query, ...)\n        return response.json()['finance']['result'][0]\n</code></pre> <p>By separating the building of the query (<code>EquityQuery</code>) from the execution of the search (<code>screen</code>), <code>yfinance</code> gives you a powerful and flexible way to find exactly what you're looking for.</p>"},{"location":"tutorial/03_screener___query_objects_/#conclusion","title":"Conclusion","text":"<p>You've now moved from simply fetching data to actively discovering it.</p> <ul> <li>What you learned: How to find stocks and funds that match specific criteria using the screener functionality.</li> <li>Key Tools:<ul> <li><code>yf.screen('predefined_name')</code>: For running common, pre-built searches quickly.</li> <li><code>EquityQuery</code> &amp; <code>FundQuery</code>: For building your own custom, complex search rules.</li> <li><code>yf.screen(your_query_object)</code>: For executing your custom search.</li> </ul> </li> <li>The Big Idea: You can programmatically define a set of rules and send them to Yahoo Finance to get a list of securities that match, acting as a powerful discovery tool.</li> </ul> <p>So far, all the data we've worked with has been historical or delayed. But what if you want to see stock prices change in real-time, as they do on a trading floor? For that, we need a continuous connection to the data source.</p> <p>In the next chapter, we will explore just that with the WebSocket (Live Data Streaming).</p> <p>Generated by Codebase Knowledge Builder</p>"},{"location":"tutorial/04_websocket__live_data_streaming__/","title":"Chapter 4: WebSocket (Live Data Streaming)","text":"<p>In the previous chapters on the Ticker Object and Screener &amp; Query Objects, we've been asking for data. We say, \"Give me the history for Apple,\" and <code>yfinance</code> goes and fetches it. This is like looking up a historical record in an archive. But what if you want to see the price of Apple stock change right now, as trades are happening?</p> <p>For that, you need a live feed, not an archive. This is where <code>yfinance</code>'s WebSocket comes in. It opens a continuous, live connection to Yahoo Finance, so you get price updates the moment they happen.</p>"},{"location":"tutorial/04_websocket__live_data_streaming__/#the-goal-watching-a-stock-price-live","title":"The Goal: Watching a Stock Price Live","text":"<p>Let's set a simple goal: Watch the price of Apple (<code>AAPL</code>) and Bitcoin (<code>BTC-USD</code>) change in real-time. We want our program to print out new price information as soon as it's available, just like a live ticker on a news channel.</p>"},{"location":"tutorial/04_websocket__live_data_streaming__/#the-old-way-vs-the-live-way","title":"The Old Way vs. The Live Way","text":"<p>With the tools we've used so far, you might try to solve this by repeatedly asking for the price every second.</p> <pre><code># The inefficient way (don't do this!)\nimport time\nimport yfinance as yf\n\naapl = yf.Ticker(\"AAPL\")\nwhile True:\n    price = aapl.history(period=\"1d\")['Close'][-1]\n    print(f\"AAPL price: {price}\")\n    time.sleep(1) # Wait one second and ask again\n</code></pre> <p>This is called \"polling,\" and it's inefficient. It's like calling the library every second to ask, \"Is the book I want back yet?\" Most of the time, the answer is no, and you've wasted a phone call.</p> <p>The WebSocket is a much smarter approach. It's like giving the librarian your phone number and saying, \"Call me the instant that book is returned.\" You don't have to keep asking; the information comes to you.</p>"},{"location":"tutorial/04_websocket__live_data_streaming__/#using-the-websocket-for-live-data","title":"Using the WebSocket for Live Data","text":"<p>Let's see how to set up this live feed. The process involves three simple steps: 1.  Define what to do with each piece of live data. 2.  Subscribe to the stocks you're interested in. 3.  Start listening.</p>"},{"location":"tutorial/04_websocket__live_data_streaming__/#step-1-define-a-message-handler","title":"Step 1: Define a Message Handler","text":"<p>First, we need to create a simple Python function that will be called every time a new price update arrives. This function will receive the data as a dictionary and can do whatever we want with it. For our goal, we'll just print it.</p> <pre><code># This function will process each incoming message\ndef message_handler(message):\n    print(\"Received a new update:\")\n    print(message)\n</code></pre> <p>Think of this <code>message_handler</code> as your set of instructions for the librarian. When they call you, what should you do? In this case, just announce the news.</p>"},{"location":"tutorial/04_websocket__live_data_streaming__/#step-2-subscribe-and-listen","title":"Step 2: Subscribe and Listen","text":"<p>Now, we create a <code>WebSocket</code> object, tell it which tickers to subscribe to, and start listening with our handler function.</p> <pre><code>import yfinance as yf\n\n# This function will process each incoming message\ndef message_handler(message):\n    print(message)\n\n# Create a WebSocket connection\nwith yf.WebSocket() as ws:\n    # Subscribe to Apple and Bitcoin\n    ws.subscribe([\"AAPL\", \"BTC-USD\"])\n\n    # Start listening for messages and pass them to our handler\n    ws.listen(message_handler)\n</code></pre> <p>What you'll see:</p> <p>Your program will first print some status messages like \"Connected to WebSocket.\" and \"Listening for messages...\". Then, it will sit quietly. As soon as there's a trade or price change for Apple or Bitcoin on the real-world market, a new message will instantly appear on your screen!</p> <pre><code>{'id': 'AAPL', 'price': 171.52, 'time': 1678886400, 'exchange': 'NMS', ...}\n{'id': 'BTC-USD', 'price': 24500.1, 'time': 1678886401, 'exchange': 'CCC', ...}\n{'id': 'AAPL', 'price': 171.53, 'time': 1678886402, 'exchange': 'NMS', ...}\n...and so on...\n</code></pre> <p>The program will keep running and printing updates until you stop it (usually by pressing <code>Ctrl+C</code>). You've successfully created a live data stream!</p> <p>Note: For advanced users, <code>yfinance</code> also provides an <code>AsyncWebSocket</code> for use in asynchronous Python applications, but the synchronous <code>WebSocket</code> is the easiest way to get started.</p>"},{"location":"tutorial/04_websocket__live_data_streaming__/#whats-happening-under-the-hood","title":"What's Happening Under the Hood?","text":"<p>The process is fundamentally different from a normal data request. It's a persistent conversation.</p> <ol> <li>Open the Line: When you create the <code>yf.WebSocket()</code>, your program opens a special, long-lasting connection to a Yahoo Finance server (the URL is <code>wss://streamer.finance.yahoo.com</code>). This is like opening a phone line that stays connected.</li> <li>State Your Interest: <code>ws.subscribe([\"AAPL\"])</code> sends a specific message over that line that says, \"I am interested in AAPL. Please send me updates for it.\"</li> <li>Listen and Wait: <code>ws.listen(handler)</code> starts a loop that does nothing but wait for the server to send a message. It's now in \"receive mode.\"</li> <li>Data is Pushed: When Yahoo's servers register a new trade for AAPL, they find all the open connections (like yours) that subscribed to it and push the new price data down the line.</li> <li>Process the Data: Your waiting <code>listen</code> loop receives the data, decodes it from its raw format into a clean Python dictionary, and immediately calls your <code>message_handler</code> function with that dictionary as the input.</li> </ol> <p>This \"push\" model is what makes it real-time and efficient.</p> <p>Here is a diagram illustrating the live streaming process:</p> <pre><code>sequenceDiagram\n    participant U as User/Your Code\n    participant WS as yfinance WebSocket\n    participant YAPI as Yahoo Streamer API\n\n    U-&gt;&gt;WS: yf.WebSocket()\n    WS-&gt;&gt;YAPI: Open persistent connection\n    YAPI--&gt;&gt;WS: Connection established\n\n    U-&gt;&gt;WS: ws.subscribe([\"AAPL\"])\n    WS-&gt;&gt;YAPI: Send 'subscribe' message for \"AAPL\"\n    Note right of YAPI: Server now knows to send you AAPL updates\n\n    U-&gt;&gt;WS: ws.listen(handler)\n    Note over WS: Enters a loop, waiting for messages...\n\n    loop Live Market Activity\n        YAPI--&gt;&gt;WS: PUSH: New price data for \"AAPL\"\n        WS-&gt;&gt;WS: Decode the message\n        WS-&gt;&gt;U: Call handler(decoded_message)\n    end\n</code></pre> <p>If you look inside the <code>yfinance</code> source code in the file <code>yfinance/live.py</code>, you can see this logic clearly.</p> <p>The <code>subscribe</code> method simply formats your list of symbols into a JSON message and sends it.</p> <pre><code># Simplified from yfinance/live.py inside the WebSocket class\n\ndef subscribe(self, symbols: Union[str, List[str]]):\n    # ... some setup code ...\n    self._subscriptions.update(symbols)\n\n    # This is the message sent to Yahoo's server\n    message = {\"subscribe\": list(self._subscriptions)}\n    self._ws.send(json.dumps(message))\n</code></pre> <p>The <code>listen</code> method contains the core waiting loop. It waits to receive a message, decodes it, and then passes it to your handler.</p> <pre><code># Simplified from yfinance/live.py inside the WebSocket class\n\ndef listen(self, message_handler: Optional[Callable[[dict], None]] = None):\n    # ... setup code ...\n    while True:\n        try:\n            # 1. Wait for and receive a message from the server\n            message = self._ws.recv()\n\n            # 2. Decode the raw message into a dictionary\n            decoded_message = self._decode_message(...)\n\n            # 3. If a handler was provided, call it with the data\n            if message_handler:\n                message_handler(decoded_message)\n        # ... error handling ...\n</code></pre> <p>This simple but powerful structure allows you to react to market events in real time.</p>"},{"location":"tutorial/04_websocket__live_data_streaming__/#conclusion","title":"Conclusion","text":"<p>You've now learned how to tap into a live stream of financial data, moving beyond historical analysis into the world of real-time monitoring.</p> <ul> <li>What you learned: How to get live price updates pushed to your program as they happen.</li> <li>Key Tool: The <code>yf.WebSocket</code> class, which manages a persistent connection to Yahoo's streaming servers.</li> <li>The Big Idea: Instead of repeatedly requesting (pulling) data, you subscribe once and the server pushes updates to you, which is ideal for time-sensitive applications.</li> </ul> <p>So far, we've focused on the tools for fetching data\u2014whether it's for one stock, many stocks, or a live stream. But what about the data itself? What does it mean when a stock is in the \"Technology\" sector or the \"Software\u2014Infrastructure\" industry? How can we explore these categories?</p> <p>In the next chapter, we'll dive into the concepts that organize the financial world with Domain Entities (Sector, Industry, Market).</p> <p>Generated by Codebase Knowledge Builder</p>"},{"location":"tutorial/05_domain_entities__sector__industry__market__/","title":"Chapter 5: Domain Entities (Sector, Industry, Market)","text":"<p>In the last chapter on WebSocket (Live Data Streaming), we saw how to get real-time price updates. All of our focus so far has been on individual companies, identified by their ticker symbols. But what if you want to zoom out and see the bigger picture?</p> <p>Instead of looking at a single tree (like a <code>Ticker</code> for \"MSFT\"), what if you want to analyze the entire forest (the Technology sector), a specific type of tree (the Software industry), or even the regional climate (the US market)? This is what \"Domain Entities\" are for. They let you explore financial data from a top-down perspective.</p>"},{"location":"tutorial/05_domain_entities__sector__industry__market__/#the-goal-understanding-a-market-sector","title":"The Goal: Understanding a Market Sector","text":"<p>Let's set a goal: Explore the Technology sector to understand its main sub-industries and identify its top-performing companies.</p> <p>This is a common task for investors who want to understand broad market trends before diving into individual stocks.</p>"},{"location":"tutorial/05_domain_entities__sector__industry__market__/#exploring-the-forest-the-sector-object","title":"Exploring the Forest: The <code>Sector</code> Object","text":"<p>The broadest category for classifying companies is the \"sector.\" Think of it as a major division of the economy, like 'Technology', 'Healthcare', or 'Financial Services'. <code>yfinance</code> gives us the <code>Sector</code> object to explore these.</p> <p>Let's create an object for the Technology sector. The key for it is simply <code>'technology'</code>.</p> <pre><code>import yfinance as yf\n\n# Create a Sector object for Technology\ntech = yf.Sector('technology')\n</code></pre> <p>Just like the Ticker Object, this line doesn't download any data yet. It's a \"lazy\" object waiting for your instructions.</p> <p>Now, let's ask it for some information.</p> <pre><code># Get the full name of the sector\nprint(tech.name)\n</code></pre> <p>What you'll see:</p> <pre><code>Technology\n</code></pre> <p>That was simple. Now for our main goal: who are the top companies in this sector?</p> <pre><code># Get a table of the top companies in the Technology sector\ntop_companies = tech.top_companies\n\nprint(top_companies.head()) # Print the first 5\n</code></pre> <p>What you'll see:</p> <p>You get a <code>pandas</code> DataFrame listing the major players in the technology world, neatly organized.</p> <pre><code>          name rating  market weight\nsymbol\nMSFT   Microsoft  BUY       0.198308\nAAPL       Apple  BUY       0.187399\nNVDA      NVIDIA  BUY       0.089028\nAVGO    Broadcom  BUY       0.038753\nMETA        Meta  BUY       0.033503\n</code></pre>"},{"location":"tutorial/05_domain_entities__sector__industry__market__/#examining-the-trees-the-industry-object","title":"Examining the Trees: The <code>Industry</code> Object","text":"<p>A sector is made up of more specific \"industries.\" For example, the Technology sector contains industries like \"Software,\" \"Semiconductors,\" and \"Consumer Electronics.\" We can get a list of all industries within our <code>tech</code> sector object.</p> <pre><code># Get a table of all industries within the Technology sector\nindustries_in_tech = tech.industries\n\nprint(industries_in_tech.head())\n</code></pre> <p>What you'll see:</p> <p>This gives you another DataFrame, listing all the sub-industries. Notice the <code>key</code> column, which we can use to create an <code>Industry</code> object.</p> <pre><code>                                               name      symbol  market weight\nkey\nsoftware-infrastructure           Software-Infrastructure  ^YFIN-TECSI       0.285854\nsemiconductors                           Semiconductors  ^YFIN-TECSC       0.217355\nsoftware-application               Software-Application  ^YFIN-TECSA       0.187803\ncommunication-equipment         Communication-Equipment  ^YFIN-TECCE       0.083896\nconsumer-electronics               Consumer-Electronics  ^YFIN-TECEL       0.076092\n</code></pre> <p>Let's say we're interested in 'software-infrastructure'. We can create an <code>Industry</code> object for it using its key.</p> <pre><code># Create an Industry object for Software-Infrastructure\nsoftware = yf.Industry('software-infrastructure')\n\n# Let's find its top performing companies\nprint(software.top_performing_companies.head())\n</code></pre> <p>What you'll see:</p> <p>This gives you a focused list of the best-performing companies just within that specific industry, which is much more targeted than looking at the whole sector.</p> <pre><code>             name  ytd return   last price  target price\nsymbol\nMSFT    Microsoft    0.183063   427.870000        476.02\nORCL       Oracle    0.133758   120.570000        130.33\nADBE        Adobe    0.007621   597.580000        626.33\nCRM   Salesforce   -0.036081   275.530000        323.82\nINTU       Intuit    0.015255   630.000000        672.64\n</code></pre>"},{"location":"tutorial/05_domain_entities__sector__industry__market__/#checking-the-climate-the-market-object","title":"Checking the Climate: The <code>Market</code> Object","text":"<p>Finally, what if you want the highest-level view possible? The <code>Market</code> object gives you a snapshot of a regional market's performance, like the major indices in the United States.</p> <pre><code># Create a Market object for the United States\nus_market = yf.Market('us_market')\n\n# Get a summary of the major indices\nprint(us_market.summary)\n</code></pre> <p>What you'll see:</p> <p>You'll get back a dictionary summarizing the current state of major US indices like the S&amp;P 500, Dow Jones, and NASDAQ. It's a quick way to check the overall market \"weather.\"</p> <pre><code>{'^IXIC': {'shortName': 'NASDAQ Composite', 'regularMarketPrice': 15990.66, ...},\n '^GSPC': {'shortName': 'S&amp;P 500', 'regularMarketPrice': 5087.03, ...},\n '^DJI': {'shortName': 'Dow Jones Industrial Average', 'regularMarketPrice': 39069.96, ...}}\n</code></pre>"},{"location":"tutorial/05_domain_entities__sector__industry__market__/#whats-happening-under-the-hood-efficient-lazy-loading","title":"What's Happening Under the Hood? Efficient Lazy Loading","text":"<p>You might be wondering if accessing <code>tech.name</code> and then <code>tech.top_companies</code> makes two separate requests to Yahoo Finance. The answer is no, and this is what makes these objects so efficient.</p> <p>The <code>Sector</code> and <code>Industry</code> objects use the same \"lazy loading\" principle as the <code>Ticker</code> object, but with a twist. The first time you ask for any piece of information (like <code>.name</code>), the object makes one single API call to get all the available data for that sector. It then stores this data internally. Any subsequent requests for other properties (like <code>.top_companies</code> or <code>.industries</code>) are served instantly from this stored data, requiring no new internet requests.</p> <p>Here's a diagram showing the process for our <code>tech</code> object:</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant SO as Sector Object ('tech')\n    participant YAPI as Yahoo Finance API\n\n    U-&gt;&gt;SO: yf.Sector('technology')\n    Note right of U: No data has been downloaded yet.\n\n    U-&gt;&gt;SO: tech.name\n    Note over SO: Data not loaded yet. Time to fetch!\n    SO-&gt;&gt;YAPI: Request all data for 'technology' sector\n    YAPI--&gt;&gt;SO: Return large JSON with name, top companies, industries, etc.\n    Note over SO: Parse JSON and store ALL data internally.\n    SO--&gt;&gt;U: Return tech.name (\"Technology\")\n\n    U-&gt;&gt;SO: tech.top_companies\n    Note over SO: Data is already here!\n    SO--&gt;&gt;U: Return top_companies DataFrame (No API call!)\n</code></pre> <p>This \"fetch-once, use-many-times\" strategy is managed by a clever little method inside the base <code>Domain</code> class, which <code>Sector</code> and <code>Industry</code> are built upon. If you look in <code>yfinance/domain/domain.py</code>, you'll find the gatekeeper method: <code>_ensure_fetched</code>.</p> <pre><code># Simplified from yfinance/domain/domain.py\n\ndef _ensure_fetched(self, attribute) -&gt; None:\n    \"\"\"\n    Ensures that data is fetched if the attribute is not yet loaded.\n    \"\"\"\n    if attribute is None:\n        self._fetch_and_parse()\n</code></pre> <p>Every property (like <code>.name</code>) calls this method before returning its value. If the internal variable (e.g., <code>self._name</code>) is <code>None</code>, it means the data hasn't been fetched yet. It then calls <code>_fetch_and_parse()</code>, which does the actual work.</p> <p>The <code>_fetch_and_parse()</code> method in the <code>Sector</code> class (<code>yfinance/domain/sector.py</code>) is where the specific API call happens.</p> <pre><code># Simplified from yfinance/domain/sector.py\n\nclass Sector(Domain):\n    def __init__(self, key, ...):\n        # ... setup ...\n        self._query_url: str = f'{_QUERY_URL_}/sectors/{self._key}'\n        # ...\n\n    def _fetch_and_parse(self) -&gt; None:\n        # 1. Make the API call to the specific URL for this sector\n        result = self._fetch(self._query_url)\n        data = result['data']\n\n        # 2. Parse EVERYTHING and store it\n        self._name = data.get('name')\n        self._top_companies = self._parse_top_companies(...)\n        self._industries = self._parse_industries(...)\n        # ... and so on for all properties\n</code></pre> <p>This design is elegant: the <code>_ensure_fetched</code> gatekeeper makes sure the work is only done once, and the <code>_fetch_and_parse</code> worker does all the heavy lifting in one efficient trip.</p>"},{"location":"tutorial/05_domain_entities__sector__industry__market__/#conclusion","title":"Conclusion","text":"<p>You've now learned how to move beyond individual stocks to analyze the market from a high-level, top-down perspective.</p> <ul> <li>What you learned: How to use domain entities to explore broad market categories.</li> <li>Key Tools:<ul> <li><code>yf.Sector</code>: For analyzing an entire economic sector (the \"forest\").</li> <li><code>yf.Industry</code>: For drilling down into specific industries within a sector (the \"trees\").</li> <li><code>yf.Market</code>: For getting a quick snapshot of a regional market's health (the \"climate\").</li> </ul> </li> <li>The Big Idea: These objects use efficient, \"fetch-once\" lazy loading to give you a rich, contextual view of the market without making unnecessary API calls.</li> </ul> <p>All the objects we've met so far\u2014<code>Ticker</code>, <code>Tickers</code>, <code>Sector</code>, <code>Industry</code>\u2014are high-level tools that make it easy to ask for data. But they all rely on a common, lower-level component to do the actual job of communicating with Yahoo Finance. What is this component?</p> <p>In the next chapter, we'll introduce this foundational layer: the YfData (Data Fetching Layer).</p> <p>Generated by Codebase Knowledge Builder</p>"},{"location":"tutorial/06_yfdata__data_fetching_layer__/","title":"Chapter 6: YfData (Data Fetching Layer)","text":"<p>In the previous chapter on Domain Entities (Sector, Industry, Market), we explored high-level concepts like sectors and industries. All the objects we've used so far\u2014<code>Ticker</code>, <code>Sector</code>, <code>WebSocket</code>\u2014are designed to make asking for data easy and intuitive. But have you ever wondered what's working behind the scenes to actually fetch that data from the internet?</p> <p>This chapter pulls back the curtain on the library's engine room: the <code>YfData</code> object. You won't ever need to use it directly, but understanding it is key to seeing how <code>yfinance</code> works so efficiently.</p>"},{"location":"tutorial/06_yfdata__data_fetching_layer__/#the-goal-centralizing-all-data-requests","title":"The Goal: Centralizing All Data Requests","text":"<p>Imagine a large library where every researcher goes to the shelves themselves to get books. It would be chaos! People might get in each other's way, and if two people need the same book, they'd both have to walk all the way to the shelf.</p> <p>A better system is to have a single, official librarian. Every researcher gives their request to this librarian, who then fetches the books in an organized way. This is exactly the problem <code>YfData</code> solves. It acts as the single, official librarian for the entire <code>yfinance</code> project.</p> <p>Every part of the library, whether it's a <code>Ticker</code> object asking for history or a <code>Sector</code> object asking for top companies, sends its request to the one and only <code>YfData</code> instance.</p>"},{"location":"tutorial/06_yfdata__data_fetching_layer__/#key-roles-of-the-librarian-yfdata","title":"Key Roles of the \"Librarian\" (<code>YfData</code>)","text":"<p>Our <code>YfData</code> librarian has several crucial responsibilities that make the whole library run smoothly.</p>"},{"location":"tutorial/06_yfdata__data_fetching_layer__/#1-its-a-singleton-theres-only-one-librarian","title":"1. It's a Singleton: There's Only One Librarian","text":"<p>No matter how many <code>Ticker</code> objects you create, they all share the exact same <code>YfData</code> instance. This is a programming pattern called a \"singleton.\"</p> <pre><code>import yfinance as yf\n\n# Create two different Ticker objects\nmsft = yf.Ticker(\"MSFT\")\naapl = yf.Ticker(\"AAPL\")\n\n# Let's peek inside and see their data fetcher\n# The 'is' keyword checks if they are the exact same object\nprint(msft._data is aapl._data)\n</code></pre> <p>What you'll see:</p> <pre><code>True\n</code></pre> <p>This confirms it! Both <code>msft</code> and <code>aapl</code> are talking to the same \"librarian\" (<code>_data</code> is the internal name for the <code>YfData</code> instance). This prevents conflicts and keeps communication with Yahoo Finance consistent.</p>"},{"location":"tutorial/06_yfdata__data_fetching_layer__/#2-session-management-the-master-library-card","title":"2. Session Management: The Master Library Card","text":"<p>The <code>YfData</code> object holds the network \"session,\" which is like the master library card for accessing Yahoo Finance. This session keeps track of important details for communicating with the server.</p>"},{"location":"tutorial/06_yfdata__data_fetching_layer__/#3-authentication-the-secret-handshake","title":"3. Authentication: The Secret Handshake","text":"<p>To get data from Yahoo Finance, you can't just ask. The server requires a \"cookie\" (a temporary access pass) and a \"crumb\" (a special security token). <code>YfData</code> is solely responsible for getting these credentials and attaching them to every request. It knows the \"secret handshake\" required to get data, so the <code>Ticker</code> objects don't have to.</p>"},{"location":"tutorial/06_yfdata__data_fetching_layer__/#4-caching-the-smart-librarians-desk","title":"4. Caching: The Smart Librarian's Desk","text":"<p><code>YfData</code> is smart. If you ask for Microsoft's company info, <code>YfData</code> fetches it and keeps a copy on its \"desk.\" If you ask for the same information again a moment later, it doesn't go all the way back to Yahoo's servers. It just gives you the copy it already has. This is called caching, and it makes repeated requests for the same data incredibly fast.</p>"},{"location":"tutorial/06_yfdata__data_fetching_layer__/#whats-happening-under-the-hood","title":"What's Happening Under the Hood?","text":"<p>Let's trace the journey of a simple data request to see how <code>YfData</code> does its job.</p> <ol> <li>The User's Request: You ask for company information.     <code>python     info = msft.info</code></li> <li>Delegation: The <code>msft</code> <code>Ticker</code> object doesn't know how to talk to the internet. Instead, it prepares the URL and turns to its internal data fetcher, <code>self._data</code> (our <code>YfData</code> librarian), and says, \"Please get the data from this address.\"</li> <li>The Librarian Takes Over (<code>YfData</code>):<ul> <li>Check Cache: <code>YfData</code> first checks its cache (its desk). Have I fetched this exact URL recently? If yes, it returns the stored data instantly.</li> <li>Get Credentials: If the data isn't cached, <code>YfData</code> makes sure it has a valid cookie and crumb. If not, it gets them from Yahoo Finance.</li> <li>Make the Call: It uses its shared network session to send the request to Yahoo Finance, with the correct credentials attached.</li> <li>Store and Return: When Yahoo's server responds, <code>YfData</code> stores the new data in its cache for next time and hands the result back to the <code>msft</code> <code>Ticker</code> object.</li> </ul> </li> <li>Final Polish: The <code>msft</code> object takes the raw data from <code>YfData</code> and formats it into the nice Python dictionary that you see.</li> </ol> <p>Here is a diagram of this efficient workflow:</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant TO as Ticker Object\n    participant YD as YfData (The Librarian)\n    participant YC as YfData Cache\n    participant YAPI as Yahoo Finance API\n\n    U-&gt;&gt;TO: msft.info\n    TO-&gt;&gt;YD: Please fetch data for \"info\"\n    YD-&gt;&gt;YC: Do you have \"info\" data cached?\n    alt Data is in cache\n        YC--&gt;&gt;YD: Yes, here it is.\n        YD--&gt;&gt;TO: Return cached data\n    else Data is NOT in cache\n        YC--&gt;&gt;YD: No, I don't.\n        YD-&gt;&gt;YAPI: Request \"info\" data (with cookie/crumb)\n        YAPI--&gt;&gt;YD: Return raw \"info\" data\n        YD-&gt;&gt;YC: Store this data for next time\n        YD--&gt;&gt;TO: Return new data\n    end\n    TO--&gt;&gt;U: Return formatted dictionary\n</code></pre> <p>This entire process is managed by the <code>YfData</code> class located in <code>yfinance/data.py</code>. Its singleton behavior is defined using a special \"metaclass.\"</p> <pre><code># Simplified from yfinance/data.py\n\nclass SingletonMeta(type):\n    _instances = {} # A dictionary to hold the single instance\n    # ... logic to ensure only one instance is ever created ...\n\nclass YfData(metaclass=SingletonMeta):\n    \"\"\"\n    Have one place to retrieve data from Yahoo API...\n    \"\"\"\n    def __init__(self, session=None, proxy=None):\n        self._crumb = None\n        self._cookie = None\n        # ... and other setup ...\n</code></pre> <p>When a <code>Ticker</code> object is created in <code>yfinance/base.py</code>, it gets access to this single instance.</p> <pre><code># Simplified from yfinance/base.py\n\nclass TickerBase:\n    def __init__(self, ticker, session=None):\n        # ...\n        # This line gets the one and only YfData instance!\n        self._data: YfData = YfData(session=session)\n        # ...\n</code></pre> <p>And when <code>YfData</code> makes a request, it uses methods like <code>cache_get</code> that automatically handle both caching and fetching. The <code>@lru_cache</code> is the Python decorator that provides the magic of caching.</p> <pre><code># Simplified from yfinance/data.py\n\nclass YfData(metaclass=SingletonMeta):\n    # ...\n\n    @lru_cache(maxsize=cache_maxsize) # This enables caching!\n    def cache_get(self, url, params=None, timeout=30):\n        # This method calls another method that handles\n        # cookies, crumbs, and the actual network request.\n        return self.get(url, params, timeout)\n</code></pre> <p>By centralizing all this logic, <code>yfinance</code> ensures that every part of the library is efficient, consistent, and robust.</p>"},{"location":"tutorial/06_yfdata__data_fetching_layer__/#conclusion","title":"Conclusion","text":"<p>You've now met the unsung hero of the <code>yfinance</code> library, the <code>YfData</code> object.</p> <ul> <li>What it is: The central, singleton \"librarian\" that manages all communication with Yahoo Finance.</li> <li>Why it's important: It handles session management, authentication (cookies/crumbs), and caching to make data fetching fast, efficient, and consistent across the entire library.</li> <li>How it's used: You don't use it directly. It works silently in the background, serving requests from higher-level objects like <code>Ticker</code> and <code>Sector</code>.</li> <li>The Big Idea: Centralizing the data fetching layer avoids chaos and optimizes performance, just like having a single, skilled librarian is better than a free-for-all.</li> </ul> <p>Now we know that <code>YfData</code> is responsible for fetching the raw data from Yahoo. But this raw data is often in a complex format like JSON or HTML. How does <code>yfinance</code> turn that raw data into the clean, organized <code>pandas</code> DataFrames we love to use? For that, it needs another set of specialized tools.</p> <p>In the final chapter, we'll meet these tools: the Data Scrapers.</p> <p>Generated by Codebase Knowledge Builder</p>"},{"location":"tutorial/07_data_scrapers_/","title":"Chapter 7: Data Scrapers","text":"<p>In the previous chapter on the YfData (Data Fetching Layer), we met the \"librarian\" of <code>yfinance</code>. This <code>YfData</code> object is an expert at one thing: fetching raw, unfiltered data from Yahoo Finance's servers. But this raw data is often messy, like a dense, complicated book written in a foreign language.</p> <p>How does <code>yfinance</code> turn that complex raw data into the beautiful, easy-to-use Python dictionaries and <code>pandas</code> DataFrames that we've been working with? This is the job of the Data Scrapers.</p>"},{"location":"tutorial/07_data_scrapers_/#the-goal-turning-raw-data-into-clean-information","title":"The Goal: Turning Raw Data into Clean Information","text":"<p>Imagine you ask your <code>Ticker</code> object for Microsoft's financial statements.</p> <pre><code>import yfinance as yf\n\nmsft = yf.Ticker(\"MSFT\")\n\n# How does this...\nfinancials = msft.financials\n\n# ...turn raw web data into a clean table?\nprint(financials)\n</code></pre> <p>The raw data from Yahoo Finance for financial statements is a complex JSON structure. The scrapers are the specialists that know exactly how to read this structure, pick out the important pieces, and assemble them into a structured DataFrame.</p> <p>Think of it like this: <code>YfData</code> is the librarian who brings you the ancient, dusty book. The scrapers are a team of expert translators and researchers who read the book for you and give you a neat, one-page summary.</p>"},{"location":"tutorial/07_data_scrapers_/#a-team-of-specialists","title":"A Team of Specialists","text":"<p>The main <code>Ticker</code> object doesn't do this translation work itself. Instead, it acts like a manager. When you create a <code>Ticker</code> object, it assembles a team of specialized scraper objects.</p> <ul> <li><code>Quote</code>: An expert on general company info (<code>.info</code>).</li> <li><code>Fundamentals</code>: An expert on financial statements (<code>.financials</code>, <code>.balance_sheet</code>).</li> <li><code>Holders</code>: An expert on who owns the company's stock (<code>.major_holders</code>).</li> <li><code>Analysis</code>: An expert on analyst ratings and price targets.</li> <li>And more!</li> </ul> <p>This design keeps the code clean and organized. Each scraper has one job and does it well. When you ask the <code>Ticker</code> manager for something, it knows exactly which specialist to delegate the task to.</p> <p>Let's see this delegation in action. If we ask for <code>.info</code>:</p> <pre><code># When you ask for this...\ninfo_data = msft.info\n</code></pre> <p>The <code>Ticker</code> object simply turns to its <code>Quote</code> scraper expert and says, \"get me the info.\"</p> <p>If you ask for financial data:</p> <pre><code># When you ask for this...\nbalance_sheet_data = msft.balance_sheet\n</code></pre> <p>The <code>Ticker</code> object turns to its <code>Fundamentals</code> scraper expert and asks for the balance sheet. Each request goes to the right specialist for the job.</p>"},{"location":"tutorial/07_data_scrapers_/#whats-happening-under-the-hood-the-scrapers-workflow","title":"What's Happening Under the Hood? The Scraper's Workflow","text":"<p>Let's trace the journey of a request for <code>.financials</code> to see how the manager, the specialist, and the librarian all work together.</p> <ol> <li>The User's Request: You ask the <code>Ticker</code> manager for the financial statements.     <code>python     financials = msft.financials</code></li> <li>Delegation: The <code>Ticker</code> object knows this is a job for its <code>Fundamentals</code> specialist. It calls the <code>.financials</code> property on its internal <code>_fundamentals</code> object.</li> <li>The Specialist Takes Over (<code>Fundamentals</code> scraper):<ul> <li>The scraper knows the exact URL and format required to get financial data.</li> <li>It turns to the <code>YfData</code> librarian and says, \"Please fetch the raw data from this specific URL for financials.\"</li> </ul> </li> <li>The Librarian's Job (<code>YfData</code>): The <code>YfData</code> object fetches the raw, messy JSON data from Yahoo Finance and hands it back to the <code>Fundamentals</code> scraper.</li> <li>Parsing and Cleaning: This is the scraper's most important job. It takes the complex JSON, navigates its structure, extracts the relevant numbers and dates, and carefully arranges them into a clean <code>pandas</code> DataFrame.</li> <li>Return: The <code>Fundamentals</code> scraper hands the finished, polished DataFrame back to the <code>Ticker</code> manager, which then gives it to you.</li> </ol> <p>Here is a diagram showing this clear division of labor:</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant TO as Ticker Object (Manager)\n    participant FS as Fundamentals Scraper (Specialist)\n    participant YD as YfData (Librarian)\n    participant YAPI as Yahoo Finance API\n\n    U-&gt;&gt;TO: msft.financials\n    TO-&gt;&gt;FS: Get financials data\n    FS-&gt;&gt;YD: Please fetch raw data for financials\n    YD-&gt;&gt;YAPI: Request raw financials JSON\n    YAPI--&gt;&gt;YD: Return raw JSON\n    YD--&gt;&gt;FS: Here is the raw data\n    Note over FS: Parse and clean the messy JSON into a DataFrame\n    FS--&gt;&gt;TO: Return clean DataFrame\n    TO--&gt;&gt;U: Return clean DataFrame\n</code></pre> <p>This elegant design is visible right in the source code. When a <code>Ticker</code> object is created in <code>yfinance/base.py</code>, it immediately initializes its team of specialists.</p> <pre><code># Simplified from yfinance/base.py in the TickerBase __init__ method\n\nclass TickerBase:\n    def __init__(self, ticker, session=None):\n        # ... some setup code ...\n        self._data: YfData = YfData(session=session) # Gets the librarian\n\n        # Assembles the team of specialists!\n        self._analysis = Analysis(self._data, self.ticker)\n        self._holders = Holders(self._data, self.ticker)\n        self._quote = Quote(self._data, self.ticker)\n        self._fundamentals = Fundamentals(self._data, self.ticker)\n        # ... and so on\n</code></pre> <p>Each scraper is given a reference to the <code>_data</code> librarian so it can request data.</p> <p>Then, when you access a property like <code>.financials</code> (which is an alias for <code>.get_income_stmt</code>), the <code>TickerBase</code> object simply delegates.</p> <pre><code># Simplified from yfinance/base.py\n\n    def get_income_stmt(self, ...):\n        # It just passes the job to the specialist\n        data = self._fundamentals.financials.get_income_time_series(...)\n        return data\n</code></pre> <p>Finally, inside the scraper itself (e.g., <code>yfinance/scrapers/fundamentals.py</code>), you find the real work: fetching the raw data via the librarian (<code>self._data</code>) and then carefully parsing it into a DataFrame.</p> <pre><code># Simplified from yfinance/scrapers/fundamentals.py inside the Financials class\n\n    def _get_financials_time_series(self, timescale, keys: list) -&gt; pd.DataFrame:\n        # 1. It constructs the specific URL needed for this data type\n        url = f\"https://.../timeseries/{self._symbol}?type={...}\"\n\n        # 2. It asks the librarian to fetch the raw data\n        json_str = self._data.cache_get(url=url).text\n        json_data = json.loads(json_str)\n        data_raw = json_data[\"timeseries\"][\"result\"]\n\n        # 3. It does the hard work of parsing the JSON into a DataFrame\n        # ... (complex parsing logic here) ...\n        df = pd.DataFrame(...)\n\n        return df\n</code></pre> <p>This separation of concerns\u2014manager, specialist, librarian\u2014is what makes the <code>yfinance</code> library so powerful yet maintainable.</p>"},{"location":"tutorial/07_data_scrapers_/#conclusion-the-full-picture","title":"Conclusion: The Full Picture","text":"<p>Congratulations! You have completed the tour of <code>yfinance</code>'s architecture. You now understand the entire process, from your simple request to the final, clean data you receive.</p> <ul> <li>What you learned: Data Scrapers are specialized classes that translate raw, messy web data into clean, usable Python objects.</li> <li>Key Idea: The <code>Ticker</code> object acts as a manager, delegating tasks to a team of scraper specialists (<code>Quote</code>, <code>Fundamentals</code>, etc.), who in turn use the <code>YfData</code> \"librarian\" to fetch raw data before parsing it.</li> <li>The Full Journey:<ol> <li>You start with a high-level object like the Ticker Object.</li> <li>This <code>Ticker</code> object delegates your request to a specialized Data Scraper (this chapter!).</li> <li>The scraper asks the central YfData (Data Fetching Layer) to fetch the raw data.</li> <li><code>YfData</code> communicates with Yahoo Finance's servers.</li> <li>The scraper receives the raw data and parses it into a clean format.</li> <li>The final, clean data is returned to you.</li> </ol> </li> </ul> <p>You've moved from being a user to being an informed developer who understands the \"why\" and \"how\" behind the library. With this knowledge, you are now fully equipped to explore, analyze, and innovate with financial data. Happy coding</p> <p>Generated by Codebase Knowledge Builder</p>"}]}